//-*-C-*-
/*******************************************************************************
*   ___   public
*  ¦OUX¦  C+
*  ¦/C+¦  OUX/C+ OS
*   ---   kernel
*         disc manager
* (c)overcq              on WSL\Debian (Linux 6.6.87.2)              2026-1-27 a
*******************************************************************************/
struct __attribute__(( __packed__ )) E_disc_Z_mbr_Z_partition_record
{ N8 bootable           :1;
  N8 reserved           :7;
  N8 start_head;
  N8 start_sector       :6;
  N8 start_cylineder_1  :2;
  N8 start_cylinder_1;
  N8 type;
  N8 end_head;
  N8 end_sector         :6;
  N8 end_cylinder_1     :2;
  N8 end_cylinder_2;
  N32 lba;
  N32 count;
};
struct __attribute__(( __packed__ )) E_disc_Z_mbr
{ N8 boot_code_0[218];
  struct
  { N8 reserved[2];
    N8 drive;
    N8 seconds;
    N8 minutes;
    N8 hours;
  }timestamp;
  N8 boot_code_1[216];
  N32 disc_signature;
  N16 copy_protected;
  struct E_disc_Z_mbr_Z_partition_record partition[4];
  N16 mbr_signature;
};
struct __attribute__(( __packed__ )) E_disc_Z_gpt_header
{ N64 signature;
  N32 revision;
  N32 size;
  N32 crc32;
  N32 reserved;
  N64 my_lba;
  N64 alternate_lba;
  N64 first_usable_lba;
  N64 last_usable_lba;
  N8 disc_guid[16];
  N64 partition_entry_lba;
  N32 partition_entry_count;
  N32 partition_entry_size;
  N32 partition_entry_crc32;
};
struct __attribute__(( __packed__ )) E_disc_Z_gpt_partition_record
{ N8 type_guid[16];
  N8 unique_guid[16];
  N64 start_lba;
  N64 end_lba;
  N64 required      :1;
  N64 no_block_io   :1;
  N64 legacy_bios   :1;
  N64 reserved      :45;
  N64 guid_reserved :16;
  C name[72];
};
//------------------------------------------------------------------------------
enum E_disc_Z_file_system
{ E_disc_Z_file_system_S_unknown
, E_disc_Z_file_system_S_oux
};
struct E_disc_Z_partition
{ enum E_disc_Z_file_system file_system;
  N pba; // physical block address
  N count;
  union
  { struct
    { N64 block_table_size;
      struct E_ouxfs_Z_block *block_table;
      N64 block_table_n;
      N64 block_table_changed_from;
      N64 block_table_block_table_n;
      struct E_ouxfs_Z_directory *directory;
      N64 directory_n;
      N64 directory_table_changed_from;
      N64 block_table_directory_table_start, block_table_directory_table_n;
      struct E_ouxfs_Z_file *file;
      N64 file_n;
      N64 file_table_changed_from;
      N64 block_table_file_table_start, block_table_file_table_n;
      struct E_ouxfs_Z_block *free_table;
      N64 free_table_n;
      N16 sector_size;
      N16 first_sector_max_size;
    }oux;
  };
  B lock;
};
enum E_disc_Z_type
{ E_disc_Z_type_S_unknown
, E_disc_Z_type_S_sata_ahci
, E_disc_Z_type_S_satapi_ahci
};
struct E_disc_Z
{ enum E_disc_Z_type type;
  union
  { struct
    { volatile struct E_sata_Z_memory *memory;
      struct E_ssd_cache_Z *ssd_cache;
      N ssd_cache_n;
      struct E_ssd_cache_Z_dirty *dirty;
      N dirty_n;
      struct E_sata_Z_dsm_range *trim_list;
      N trim_list_n;
      N logical_sector_n;
      N16 logical_sector_size, physical_sector_size;
      N8 logical_sector_shift;
      N8 port;
      N8 queue_n;
      B sata_lock;
      B ssd_cache_lock;
      unsigned trim     :1;
    }sata_ahci;
    struct
    { volatile struct E_sata_Z_memory *memory;
      N8 port;
    }satapi_ahci;
  };
  struct E_disc_Z_partition *partition;
  N partition_n;
};
//==============================================================================
_private struct E_mem_Q_tab_Z *E_disc_S;
//==============================================================================
_private
N
E_disc_M( void
){  E_disc_S = E_mem_Q_tab_M( sizeof( struct E_disc_Z ), 0 );
    if( !E_disc_S )
        return ~0;
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_export
N32
E_main_I_crc32_ieee( N8 *data
, N l
){  N32 crc = 0xFFFFFFFF;
    while( l-- )
    {   crc ^= *data++;
        for_n( i, 8 )
            if( crc & 1 )
                crc = ( crc >> 1 ) ^ 0xEDB88320;
            else
                crc >>= 1;
    }
    return crc ^ 0xFFFFFFFF;
}
_private
N
E_disc_I_init( I disc_id
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    disc->partition_n = 0;
    Mt_( disc->partition, disc->partition_n );
    if( !disc->partition )
        return ~2;
    switch( disc->type )
    { case E_disc_Z_type_S_sata_ahci:
        {   disc->sata_ahci.sata_lock = 0;
            disc->sata_ahci.ssd_cache_lock = 0;
            N r = E_ssd_cache_I_init(disc);
            if(r)
                return r;
            struct E_disc_Z_mbr *mbr = M( disc->sata_ahci.logical_sector_size );
            if( !mbr )
                return ~2;
            N32 slot_mask;
            if( E_sata_Q_sata_ahci_I_read( disc_id, 0, 1, mbr, &slot_mask ))
                return ~2;
            if( E_sata_Q_sata_ahci_I_wait_on_completion( disc, slot_mask ))
                return ~2;
            disc = E_mem_Q_tab_R( E_disc_S, disc_id );
            if( mbr->mbr_signature != 0xaa55 )
                return W(mbr) ? ~1 : 0;
            for_n( i, 4 )
            {   switch( mbr->partition[i].type )
                { case 0xee:
                    {   slot_mask = 0;
                        struct E_disc_Z_gpt_header *gpt_header = M( disc->sata_ahci.logical_sector_size );;
                        if( E_sata_Q_sata_ahci_I_read( disc_id, 1, 1, gpt_header, &slot_mask ))
                            return ~2;
                        if( E_sata_Q_sata_ahci_I_wait_on_completion( disc, slot_mask ))
                            return ~2;
                        disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                        if( gpt_header->signature != 0x5452415020494645
                        || gpt_header->size < 92
                        || gpt_header->size > disc->sata_ahci.logical_sector_size
                        || gpt_header->size % sizeof( N32 )
                        )
                            return ~2;
                        N32 crc32 = gpt_header->crc32;
                        gpt_header->crc32 = 0;
                        if( E_main_I_crc32_ieee( (P)gpt_header, gpt_header->size ) != crc32 )
                            return ~2;
                        if( gpt_header->my_lba != 1
                        || gpt_header->partition_entry_lba != 2
                        )
                            return ~2;
                        if( !E_simple_Z_n_T_power_2( gpt_header->partition_entry_size ))
                            return ~2;
                        if( gpt_header->partition_entry_size & 0x3f )
                            return ~2;
                        slot_mask = 0;
                        N first_usable_lba = gpt_header->partition_entry_lba
                        + E_simple_Z_n_I_align_up_to_v2( (N)gpt_header->partition_entry_count * gpt_header->partition_entry_size, disc->sata_ahci.logical_sector_size ) / disc->sata_ahci.logical_sector_size;
                        if( gpt_header->first_usable_lba != first_usable_lba )
                            return ~2;
                        first_usable_lba += disc->sata_ahci.logical_sector_shift;
                        N last_usable_lba = disc->sata_ahci.logical_sector_n - 1
                        - E_simple_Z_n_I_align_up_to_v2( (N)gpt_header->partition_entry_count * gpt_header->partition_entry_size, disc->sata_ahci.logical_sector_size ) / disc->sata_ahci.logical_sector_size
                        - 1;
                        if( gpt_header->last_usable_lba != last_usable_lba )
                            return ~2;
                        if( disc->sata_ahci.logical_sector_shift )
                            last_usable_lba -= disc->sata_ahci.physical_sector_size / disc->sata_ahci.logical_sector_size - disc->sata_ahci.logical_sector_shift;
                        struct E_disc_Z_gpt_partition_record *gpt_partition_record = M( E_simple_Z_n_I_align_up_to_v2( (N)gpt_header->partition_entry_count * gpt_header->partition_entry_size, disc->sata_ahci.logical_sector_size ));
                        if( E_sata_Q_sata_ahci_I_read( disc_id
                        , gpt_header->partition_entry_lba
                        , E_simple_Z_n_I_align_up_to_v2( (N)gpt_header->partition_entry_count * gpt_header->partition_entry_size, disc->sata_ahci.logical_sector_size ) / disc->sata_ahci.logical_sector_size
                        , gpt_partition_record
                        , &slot_mask
                        ))
                            return ~2;
                        if( E_sata_Q_sata_ahci_I_wait_on_completion( disc, slot_mask ))
                            return ~2;
                        disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                        crc32 = gpt_header->partition_entry_crc32;
                        gpt_header->partition_entry_crc32 = 0;
                        if( E_main_I_crc32_ieee( (P)gpt_partition_record, gpt_header->partition_entry_count * sizeof( *gpt_partition_record )) != crc32 )
                            return ~2;
                        //TODO Sprawdzić alternatywny GPT.
                        for_n( partition_record_i, gpt_header->partition_entry_count )
                        {   for_n( i, J_a_R_n( gpt_partition_record->type_guid ))
                                if( gpt_partition_record->type_guid[i] )
                                    break;
                            if( i != J_a_R_n( gpt_partition_record->type_guid ))
                            {   if( gpt_partition_record->start_lba < first_usable_lba
                                || gpt_partition_record->end_lba > last_usable_lba
                                || gpt_partition_record->start_lba % ( disc->sata_ahci.physical_sector_size / disc->sata_ahci.logical_sector_size ) != disc->sata_ahci.logical_sector_shift
                                || ( gpt_partition_record->end_lba - gpt_partition_record->start_lba + 1 ) % ( disc->sata_ahci.physical_sector_size / disc->sata_ahci.logical_sector_size )
                                )
                                    return ~2;
                                struct E_disc_Z_partition *partition = E_mem_Q_blk_I_append( &disc->partition, 1 );
                                if( !partition )
                                    return ~2;
                                disc->partition_n++;
                                partition->pba = gpt_partition_record->start_lba / ( disc->sata_ahci.physical_sector_size / disc->sata_ahci.logical_sector_size );
                                partition->count = ( gpt_partition_record->end_lba - gpt_partition_record->start_lba + 1 ) / ( disc->sata_ahci.physical_sector_size / disc->sata_ahci.logical_sector_size );
                                for_n( partition_i, disc->partition_n )
                                {   if( partition_i == disc->partition_n - 1 )
                                        continue;
                                    if(( disc->partition[ partition_i ].pba >= partition->pba
                                      && disc->partition[ partition_i ].pba < partition->pba + partition->count
                                    )
                                    || ( disc->partition[ partition_i ].pba + disc->partition[ partition_i ].count > partition->pba
                                      && disc->partition[ partition_i ].pba + disc->partition[ partition_i ].count <= partition->pba + partition->count
                                    ))
                                        return ~2;
                                }
                                if( !E_text_Z_sl_T_eq(( Pc )&gpt_partition_record->type_guid[0]
                                , "\xc1\x2a\x73\x28\xf8\x1f\x11\xd2\xba\x4b\x00\xa0\xc9\x3e\xc9\x3b"
                                , sizeof( gpt_partition_record->type_guid )
                                )) // EFI
                                {   G( "EFI" );
                                }else
                                {   G( "other" );
                                }
                                partition->lock = 0;
                                if( !E_ouxfs_Q_device_M( disc_id, disc->partition_n - 1 ))
                                {   G( "ouxfs" );
                                    partition->file_system = E_disc_Z_file_system_S_oux;
                                }else
                                {   G( "unknown" );
                                    partition->file_system = E_disc_Z_file_system_S_unknown;
                                }
                            }
                            gpt_partition_record = (P)(( Pc )gpt_partition_record + gpt_header->partition_entry_size );
                        }
                        break;
                    }
                }
            }
            r = W(mbr);
            if(r)
                return ~1;
            break;
        }
      case E_disc_Z_type_S_satapi_ahci:
            break;
      default:
            G( "unknown disc type" );
            return ~0;
    }
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_private
N
E_disc_I_dirty( I disc_id
, N partition_i
, N pba
, N count
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    pba += disc->partition[ partition_i ].pba;
    if( pba + count > disc->partition[ partition_i ].pba + disc->partition[ partition_i ].count )
        return ~0;
    switch( disc->type )
    { case E_disc_Z_type_S_sata_ahci:
        {   G( "dirty %x, %x", pba, count );
            N r_ = E_ssd_cache_P_dirty( disc, pba, count );
            if( r_ )
                return r_;
            break;
        }
      default:
            return ~0;
    }
    return 0;
}
_private
N
E_disc_I_read( I disc_id
, N partition_i
, N pba
, N count
, P data
, N *r
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    pba += disc->partition[ partition_i ].pba;
    if( pba + count > disc->partition[ partition_i ].pba + disc->partition[ partition_i ].count )
        return ~0;
    switch( disc->type )
    { case E_disc_Z_type_S_sata_ahci:
        {   G( "read %x, %x", pba, count );
            N r_ = E_ssd_cache_I_read( disc_id, pba, count, data, r );
            if( r_ )
                return r_;
            break;
        }
      default:
            return ~0;
    }
    return 0;
}
_private
N
E_disc_I_write( I disc_id
, N partition_i
, N pba
, N count
, P data
, N *r
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    pba += disc->partition[ partition_i ].pba;
    if( pba + count > disc->partition[ partition_i ].pba + disc->partition[ partition_i ].count )
        return ~0;
    switch( disc->type )
    { case E_disc_Z_type_S_sata_ahci:
        {   N r_ = E_ssd_cache_I_write( disc_id, pba, count, data, r );
            if( r_ )
                return r_;
            break;
        }
      default:
            return ~0;
    }
    return 0;
}
/******************************************************************************/
