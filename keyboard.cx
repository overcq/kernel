//-*-C-*-
/*******************************************************************************
*   ___   public
*  ¦OUX¦  C+
*  ¦/C+¦  OUX/C+ OS
*   ---   kernel
*         keyboard driver
* ©overcq                on ‟Gentoo Linux 23.0” “x86_64”              2025‒6‒5 Q
*******************************************************************************/
#define E_keyboard_Z_led_S_scroll_lock  ( 1 << 0 )
#define E_keyboard_Z_led_S_num_lock     ( 1 << 1 )
#define E_keyboard_Z_led_S_caps_lock    ( 1 << 2 )
#define E_keyboard_S_rw_timeout         1000
//==============================================================================
_internal volatile N8 E_keyboard_S_reply;
//==============================================================================
_private
N
E_keyboard_I_wait_read( N timeout
){  N time;
    E_flow_Q_spin_time_M( &time, timeout ? timeout : E_keyboard_S_rw_timeout );
    O{  N8 v = E_main_I_in_8( 0x64 );
        if( v & 1 )
            break;
        if( E_flow_Q_spin_time_T( &time ))
            return ~0;
        __asm__ volatile (
        "\n"    "pause"
        );
    }
    return 0;
}
_private
N
E_keyboard_I_wait_write( void
){  N time;
    E_flow_Q_spin_time_M( &time, E_keyboard_S_rw_timeout );
    O{  N8 v = E_main_I_in_8( 0x64 );
        if( !( v & 2 ))
            break;
        if( E_flow_Q_spin_time_T( &time ))
            return ~0;
        __asm__ volatile (
        "\n"    "pause"
        );
    }
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_internal
N
E_keyboard_P_led( N8 set
){  O{  if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x60, 0xed );
        if( E_keyboard_I_wait_write() )
            return ~0;
        E_keyboard_S_reply = 0;
        E_main_I_out_8( 0x60, set );
        E_flow_I_sleep( E_keyboard_S_rw_timeout );
        if( E_keyboard_S_reply == 0xfa )
            break;
    }
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_internal
void
E_keyboard_I_interrupt( void
){  N8 v = E_main_I_in_8( 0x60 );
    if( v == 0xfa
    || v == 0xfe
    )
    {   E_keyboard_S_reply = v;
        return;
    }
    N32 sched = E_flow_I_current_scheduler();
    U_F( E_flow_S_scheduler[sched].state, inside_interrupt );
    G( "keyboard interrupt, key=%8x", v );
    U_L( E_flow_S_scheduler[sched].state, inside_interrupt );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_private
N
E_keyboard_M( void
){  if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xad ); // Wyłącz port 1.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xa7 ); // Wyłącz port 2.
    O{  N8 v = E_main_I_in_8( 0x64 );
        if( !( v & 1 ))
            break;
        E_main_I_in_8( 0x60 );
    }
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x20 ); // Wczytaj konfigurację.
    if( E_keyboard_I_wait_read(0) )
        return ~0;
    N8 start_conf = E_main_I_in_8( 0x60 );
    N8 v = start_conf;
    v &= ~(( 1 << 6 ) | ( 1 << 4 ) | 1 );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x60 ); // Ustaw konfigurację.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x60, v );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xaa ); // Wykonaj test kontrolera.
    if( E_keyboard_I_wait_read(0) )
        return ~0;
    v = E_main_I_in_8( 0x60 );
    if( v != 0x55 )
        return ~0;
    v = start_conf;
    v &= ~(( 1 << 6 ) | ( 1 << 4 ) | 1 );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x60 ); // Ustaw konfigurację.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x60, v );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xa8 ); // Włącz port 2.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x20 ); // Wczytaj konfigurację.
    if( E_keyboard_I_wait_read(0) )
        return ~1;
    v = E_main_I_in_8( 0x60 );
    E_mouse_S_initialized = !( v & ( 1 << 5 ));
    if( E_mouse_S_initialized )
    {   if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0xa7 ); // Wyłącz port 2.
        v = start_conf;
        v &= ~(( 1 << 6 ) | ( 1 << 4 ) | 1 );
        v &= ~(( 1 << 5 ) | ( 1 << 1 ));
        if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0x60 ); // Ustaw konfigurację.
        if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x60, v );
    }
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xab ); // Wykonaj test portu 1.
    if( E_keyboard_I_wait_read(0) )
        return ~0;
    v = E_main_I_in_8( 0x60 );
    if(v)
        return ~0;
    if( E_mouse_S_initialized )
    {   if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0xa9 ); // Wykonaj test portu 2.
        if( E_keyboard_I_wait_read(0) )
            return ~0;
        v = E_main_I_in_8( 0x60 );
        if(v)
            E_mouse_S_initialized = no;
    }
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xae ); // Włącz port 1.
    if( E_mouse_S_initialized )
    {   if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0xa8 ); // Włącz port 2.
    }
    v = start_conf;
    v &= ~( 1 << 4 );
    v |= 1;
    if( E_mouse_S_initialized )
    {   v &= ~( 1 << 5 );
        v |= 1 << 1;
    }
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x60 ); // Ustaw konfigurację.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x60, v );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x60, 0xff ); // Zresetuj port 1.
    if( E_keyboard_I_wait_read(0) )
        return ~0;
    v = E_main_I_in_8( 0x60 );
    if( v != 0xfa )
        return ~0;
    if( E_keyboard_I_wait_read(0) )
        return ~0;
    v = E_main_I_in_8( 0x60 );
    if( v != 0xaa )
        return ~0;
    O{  v = E_main_I_in_8( 0x64 );
        if( !( v & 1 ))
            break;
        E_main_I_in_8( 0x60 );
    }
    if( E_mouse_S_initialized )
    {   if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0xd4 );
        if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x60, 0xff ); // Zresetuj port 2.
        if( E_keyboard_I_wait_read(0) )
            return ~0;
        v = E_main_I_in_8( 0x60 );
        if( v == 0xfa )
        {   if( E_keyboard_I_wait_read(0) )
                return ~0;
            v = E_main_I_in_8( 0x60 );
            if( v == 0xaa )
            {   O{  v = E_main_I_in_8( 0x64 );
                    if( !( v & 1 ))
                        break;
                    E_main_I_in_8( 0x60 );
                }
            }else
                E_mouse_S_initialized = no;
        }else
            E_mouse_S_initialized = no;
    }
    E_interrupt_P( 1, &E_keyboard_I_interrupt );
    G( "Keyboard initialized." );
    return 0;
}
/******************************************************************************/
