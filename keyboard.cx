//-*-C-*-
/*******************************************************************************
*   ___   public
*  ¦OUX¦  C+
*  ¦/C+¦  OUX/C+ OS
*   ---   kernel
*         keyboard driver
* ©overcq                on ‟Gentoo Linux 23.0” “x86_64”              2025‒6‒5 Q
*******************************************************************************/
#define E_keyboard_Z_led_S_scroll_lock  ( 1 << 0 )
#define E_keyboard_Z_led_S_num_lock     ( 1 << 1 )
#define E_keyboard_Z_led_S_caps_lock    ( 1 << 2 )
#define E_keyboard_S_rw_timeout         1000
#define E_keyboard_S_queue_n            16
//==============================================================================
struct E_keyboard_S_key
{ N8 code;
  B ex;
  B up;
};
//==============================================================================
_internal volatile N8 E_keyboard_S_reply;
_internal B E_keyboard_S_ex;
_private volatile struct E_keyboard_S_key *E_keyboard_S_queue;
_private volatile N8 E_keyboard_S_queue_i;
_internal volatile N8 E_keyboard_S_led_set;
_internal volatile B E_keyboard_S_led_set_changed, E_keyboard_S_queue_changed;
//==============================================================================
_private
N
E_keyboard_I_wait_read( void
){  N time;
    E_flow_Q_spin_time_M( &time, E_keyboard_S_rw_timeout );
    O{  N8 v = E_main_I_in_8( 0x64 );
        if( v & 1 )
            break;
        if( E_flow_Q_spin_time_T( &time ))
            return ~0;
        __asm__ volatile (
        "\n"    "pause"
        );
    }
    return 0;
}
_private
N
E_keyboard_I_wait_write( void
){  N time;
    E_flow_Q_spin_time_M( &time, E_keyboard_S_rw_timeout );
    O{  N8 v = E_main_I_in_8( 0x64 );
        if( !( v & 2 ))
            break;
        if( E_flow_Q_spin_time_T( &time ))
            return ~0;
        __asm__ volatile (
        "\n"    "pause"
        );
    }
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_internal
N
E_keyboard_P_led( N8 set
){  O{  if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x60, 0xed );
        if( E_keyboard_I_wait_write() )
            return ~0;
        E_keyboard_S_reply = 0;
        E_main_I_out_8( 0x60, set );
        E_flow_I_sleep( E_keyboard_S_rw_timeout );
        if( E_keyboard_S_reply == 0xfa )
            break;
    }
    return 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_internal
void
E_keyboard_I_interrupt( void
){  N8 v = E_main_I_in_8( 0x60 );
    if( v == 0xfa
    || v == 0xfe
    )
    {   E_keyboard_S_reply = v;
        return;
    }
    if( v == 0xe0 )
    {   E_keyboard_S_ex = yes;
        return;
    }
    N32 sched_i = E_flow_I_current_scheduler();
    U_F( E_flow_S_scheduler[ sched_i ].state, inside_interrupt );
    if( v == 0x3a
    || v == ( 0x3a | 0x80 ))
    {   if( !( v & 0x80 ))
        {   E_keyboard_S_led_set ^= E_keyboard_Z_led_S_caps_lock;
            E_keyboard_S_led_set_changed = yes;
            X_A( keyboard, key );
            X_F( keyboard, key );
        }
        return;
    }
    if( v == 0x45
    || v == ( 0x45 | 0x80 ))
    {   if( !( v & 0x80 ))
        {   E_keyboard_S_led_set ^= E_keyboard_Z_led_S_num_lock;
            E_keyboard_S_led_set_changed = yes;
            X_A( keyboard, key );
            X_F( keyboard, key );
        }
        return;
    }
    if( v == 0x46
    || v == ( 0x46 | 0x80 ))
    {   if( !( v & 0x80 ))
        {   E_keyboard_S_led_set ^= E_keyboard_Z_led_S_scroll_lock;
            E_keyboard_S_led_set_changed = yes;
            X_A( keyboard, key );
            X_F( keyboard, key );
        }
        return;
    }
    if( E_keyboard_S_queue_i == E_keyboard_S_queue_n )
    {   G( "keyboard queue full" );
        return;
    }
    E_keyboard_S_queue[ E_keyboard_S_queue_i ].up = v & 0x80;
    E_keyboard_S_queue[ E_keyboard_S_queue_i ].code = v & ~0x80;
    E_keyboard_S_queue[ E_keyboard_S_queue_i ].ex = E_keyboard_S_ex;
    E_keyboard_S_queue_i++;
    E_keyboard_S_ex = no;
    E_keyboard_S_queue_changed = yes;
    X_A( keyboard, key );
    X_F( keyboard, key );
    U_L( E_flow_S_scheduler[ sched_i ].state, inside_interrupt );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_private
N
E_keyboard_M( void
){  if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xad ); // Wyłącz port 1.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xa7 ); // Wyłącz port 2.
    O{  N8 v = E_main_I_in_8( 0x64 );
        if( !( v & 1 ))
            break;
        E_main_I_in_8( 0x60 );
    }
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x20 ); // Wczytaj konfigurację.
    if( E_keyboard_I_wait_read() )
        return ~0;
    N8 start_conf = E_main_I_in_8( 0x60 );
    N8 v = start_conf;
    v &= ~(( 1 << 6 ) | ( 1 << 4 ) | 1 );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x60 ); // Ustaw konfigurację.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x60, v );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xaa ); // Wykonaj test kontrolera.
    if( E_keyboard_I_wait_read() )
        return ~0;
    v = E_main_I_in_8( 0x60 );
    if( v != 0x55 )
        return ~0;
    v = start_conf;
    v &= ~(( 1 << 6 ) | ( 1 << 4 ) | 1 );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x60 ); // Ustaw konfigurację.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x60, v );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xa8 ); // Włącz port 2.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x20 ); // Wczytaj konfigurację.
    if( E_keyboard_I_wait_read() )
        return ~1;
    v = E_main_I_in_8( 0x60 );
    E_mouse_S_initialized = !( v & ( 1 << 5 ));
    if( E_mouse_S_initialized )
    {   if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0xa7 ); // Wyłącz port 2.
        v = start_conf;
        v &= ~(( 1 << 6 ) | ( 1 << 4 ) | 1 );
        v &= ~(( 1 << 5 ) | ( 1 << 1 ));
        if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0x60 ); // Ustaw konfigurację.
        if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x60, v );
    }
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xab ); // Wykonaj test portu 1.
    if( E_keyboard_I_wait_read() )
        return ~0;
    v = E_main_I_in_8( 0x60 );
    if(v)
        return ~0;
    if( E_mouse_S_initialized )
    {   if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0xa9 ); // Wykonaj test portu 2.
        if( E_keyboard_I_wait_read() )
            return ~0;
        v = E_main_I_in_8( 0x60 );
        if(v)
            E_mouse_S_initialized = no;
    }
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0xae ); // Włącz port 1.
    if( E_mouse_S_initialized )
    {   if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0xa8 ); // Włącz port 2.
    }
    v = start_conf;
    v &= ~( 1 << 4 );
    v |= 1;
    if( E_mouse_S_initialized )
    {   v &= ~( 1 << 5 );
        v |= 1 << 1;
    }
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x64, 0x60 ); // Ustaw konfigurację.
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x60, v );
    if( E_keyboard_I_wait_write() )
        return ~0;
    E_main_I_out_8( 0x60, 0xff ); // Zresetuj port 1.
    if( E_keyboard_I_wait_read() )
        return ~0;
    v = E_main_I_in_8( 0x60 );
    if( v != 0xfa )
        return ~0;
    if( E_keyboard_I_wait_read() )
        return ~0;
    v = E_main_I_in_8( 0x60 );
    if( v != 0xaa )
        return ~0;
    O{  v = E_main_I_in_8( 0x64 );
        if( !( v & 1 ))
            break;
        E_main_I_in_8( 0x60 );
    }
    if( E_mouse_S_initialized )
    {   if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x64, 0xd4 );
        if( E_keyboard_I_wait_write() )
            return ~0;
        E_main_I_out_8( 0x60, 0xff ); // Zresetuj port 2.
        if( E_keyboard_I_wait_read() )
            return ~0;
        v = E_main_I_in_8( 0x60 );
        if( v == 0xfa )
        {   if( E_keyboard_I_wait_read() )
                return ~0;
            v = E_main_I_in_8( 0x60 );
            if( v == 0xaa )
            {   O{  v = E_main_I_in_8( 0x64 );
                    if( !( v & 1 ))
                        break;
                    E_main_I_in_8( 0x60 );
                }
            }else
                E_mouse_S_initialized = no;
        }else
            E_mouse_S_initialized = no;
    }
    E_keyboard_S_ex = no;
    E_keyboard_S_queue_i = 0;
    Mt_( E_keyboard_S_queue, E_keyboard_S_queue_n );
    if( !E_keyboard_S_queue )
        return ~0;
    E_keyboard_S_led_set_changed = no;
    E_keyboard_S_queue_changed = no;
    D_M( keyboard, key, 0 )
        return ~1;
    E_interrupt_P( 1, &E_keyboard_I_interrupt );
    G( "Keyboard initialized." );
    return 0;
}
D( keyboard, key )
{   X_M( keyboard, key );
    O{  X_B( keyboard, key, 0 )
            break;
        E_flow_I_cli();
        if( E_keyboard_S_led_set_changed )
        {   E_keyboard_S_led_set_changed = no;
            E_keyboard_P_led( E_keyboard_S_led_set );
        }
        if( E_keyboard_S_queue_changed )
        {   E_keyboard_S_queue_changed = no;
            E_gui_Q_keyboard_I_key();
        }
        E_flow_I_sti();
    }
    X_W( keyboard, key );
}
/******************************************************************************/
