//-*-C-*-
/*******************************************************************************
*   ___   public
*  ¦OUX¦  C+
*  ¦/C+¦  OUX/C+ OS
*   ---   kernel
*         OUX filesystem manager
* ©overcq                on ‟Gentoo Linux 23.0” “x86_64”             2024‒6‒22 O
*******************************************************************************/
//DFN Rozmiary fragmentów tablicy bloków na dysku zawsze są ustawione tak, że wpisy wypełniają je całe.
//DFN Tablice bloków na dysku są posortowane według sektora, a następnie według lokalizacji w sektorze. Tablice plików i katalogów – według ‘uid’.
//TODO Co do plików zwykłych pozostaje decyzja, jak ograniczać fragmentację, a nie zużywać nośnika na zapis danych.
//==============================================================================
#define E_ouxfs_Q_device_S_ident    "OUXFS"
//==============================================================================
enum E_ouxfs_Z_block_Z_location
{ E_ouxfs_Z_block_Z_location_S_sectors
, E_ouxfs_Z_block_Z_location_S_in_sector
};
//DFN Wpis na dysku ma kolejność:
// • sector
// • location_type
//   • n, pre, post
// albo
//   • start, size
struct E_ouxfs_Z_block
{ N64 sector;
  union
  { struct
    { N64 n;
      N16 pre, post; // Wartości od 0 do “E_ouxfs_Q_device_S[ device_i ].sector_size - 1”.
    }sectors;
    struct
    { N16 start; // Wartości od 0 do “E_ouxfs_Q_device_S[ device_i ].sector_size - 1”.
      N16 size; // Wartości od 0 do “E_ouxfs_Q_device_S[ device_i ].sector_size - 1”.
    }in_sector;
  }location; //DFN Jeśli “!sectors.n” oraz “!sectors.pre || !sectors.post”, to ustawić “in_sector”.
  enum E_ouxfs_Z_block_Z_location location_type;
};
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
enum E_ouxfs_Z_file_Z_lock
{ E_ouxfs_Z_file_Z_lock_S_unlock
, E_ouxfs_Z_file_Z_lock_S_exclusive
, E_ouxfs_Z_file_Z_lock_S_shared
};
struct E_ouxfs_Z_file
{ N64 uid; // Wartości oprócz “~0”. Klucz sortowania rosnąco.
  N64 parent; // “~0” oznacza katalog główny.
  struct
  { N64 start;
    N64 n;
  }block_table;
  Pc name;
  unsigned lock_write   :1;
  unsigned lock_read    :1;
};
struct E_ouxfs_Z_directory
{ N64 uid; // Wartości oprócz “~0”. Klucz sortowania rosnąco.
  N64 parent; // “~0” oznacza katalog główny.
  Pc name;
};
//==============================================================================
_internal
B
E_ouxfs_Q_block_T_cross( I disc_id
, N partition_i
, const struct E_ouxfs_Z_block *block_1
, const struct E_ouxfs_Z_block *block_2
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( block_1->location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        if( block_2->location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if(( block_2->sector >= block_1->sector
              && block_2->sector < block_1->sector + block_1->location.sectors.n
            )
            || ( block_2->sector + block_2->location.sectors.n >= block_1->sector
              && block_2->sector + block_2->location.sectors.n
                < block_1->sector + block_1->location.sectors.n
            )
            || ( block_2->sector == block_1->sector - 1
              && block_2->location.sectors.post + block_1->location.sectors.pre > disc->sata_ahci.physical_sector_size
            )
            || ( block_1->sector == block_2->sector - 1
              && block_1->location.sectors.post + block_2->location.sectors.pre > disc->sata_ahci.physical_sector_size
            ))
                return yes;
        }else
        {   if(( block_2->sector == block_1->sector - 1
              && block_2->location.in_sector.start + block_2->location.in_sector.size
                > disc->sata_ahci.physical_sector_size - block_1->location.sectors.pre
            )
            || ( block_2->sector >= block_1->sector
              && block_2->sector < block_1->sector + block_1->location.sectors.n
            )
            || ( block_2->sector == block_1->sector + block_1->location.sectors.n
              && block_2->location.in_sector.start < block_1->location.sectors.post
            ))
                return yes;
        }
    else
        if( block_2->location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if(( block_1->sector == block_2->sector - 1
              && block_1->location.in_sector.start + block_1->location.in_sector.size
                > disc->sata_ahci.physical_sector_size - block_2->location.sectors.pre
            )
            || ( block_1->sector >= block_2->sector
              && block_1->sector < block_2->sector + block_2->location.sectors.n
            )
            || ( block_1->sector == block_2->sector + block_2->location.sectors.n
              && block_1->location.in_sector.start < block_2->location.sectors.post
            ))
                return yes;
        }else
        {   if( block_2->sector == block_1->sector
            && (( block_2->location.in_sector.start >= block_1->location.in_sector.start
                && block_2->location.in_sector.start < block_1->location.in_sector.start + block_1->location.in_sector.size
              )
              || ( block_2->location.in_sector.start + block_2->location.in_sector.size > block_1->location.in_sector.start
                && block_2->location.in_sector.start + block_2->location.in_sector.size
                  <= block_1->location.in_sector.start + block_1->location.in_sector.size
            )))
                return yes;
        }
    return no;
}
//------------------------------------------------------------------------------
_internal
N64
E_ouxfs_Z_start_n_R_size( I disc_id
, N partition_i
, N64 block_start
, N64 block_n
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    N64 size = 0;
    for_n( block_table_i, block_n )
    {   struct E_ouxfs_Z_block *block = &disc->partition[ partition_i ].oux.block_table[ block_start + block_table_i ];
        size += block->location_type == E_ouxfs_Z_block_Z_location_S_sectors
        ? block->location.sectors.pre + block->location.sectors.n * disc->sata_ahci.physical_sector_size + block->location.sectors.post
        : block->location.in_sector.size;
    }
    return size;
}
_internal
N64
E_ouxfs_Q_free_table_R( I disc_id
, N partition_i
, N64 sector
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    N64 min = 0;
    N64 max = disc->partition[ partition_i ].oux.free_table_n - 1;
    N64 free_table_i = min + ( max + 1 - min ) / 2;
    O{  if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector == sector )
            break;
        if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector > sector )
        {   if( free_table_i == min )
                break;
            max = free_table_i - 1;
            free_table_i = max - ( free_table_i - min ) / 2;
        }else
        {   if( free_table_i == max )
            {   free_table_i++; // Przesuń na “E_ouxfs_Q_device_S[ device_i ].free_table[ block_table_i ].sector > sector” lub poza zakres tablicy bloków.
                break;
            }
            min = free_table_i + 1;
            free_table_i = min + ( max - free_table_i ) / 2;
        }
    }
    return free_table_i;
}
_internal
N
E_ouxfs_Q_directory_R( I disc_id
, N partition_i
, N64 uid
, N64 *directory_i
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( !disc->partition[ partition_i ].oux.directory_n )
        return ~0;
    N64 min = 0;
    N64 max = disc->partition[ partition_i ].oux.directory_n - 1;
    N64 directory_i_ = ( max + 1 ) / 2;
    O{  if( disc->partition[ partition_i ].oux.directory[ directory_i_ ].uid == uid )
            break;
        if( disc->partition[ partition_i ].oux.directory[ directory_i_ ].uid > uid )
        {   if( directory_i_ == min )
                return ~0;
            max = directory_i_ - 1;
            directory_i_ = max - ( directory_i_ - min ) / 2;
        }else
        {   if( directory_i_ == max )
                return ~0;
            min = directory_i_ + 1;
            directory_i_ = min + ( max - directory_i_ ) / 2;
        }
    }
    *directory_i = directory_i_;
    return 0;
}
_internal
N
E_ouxfs_Q_file_R( I disc_id
, N partition_i
, N64 uid
, N64 *file_i
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( !disc->partition[ partition_i ].oux.file_n )
        return ~0;
    N64 min = 0;
    N64 max = disc->partition[ partition_i ].oux.file_n - 1;
    N64 file_i_ = ( max + 1 ) / 2;
    O{  if( disc->partition[ partition_i ].oux.file[ file_i_ ].uid == uid )
            break;
        if( disc->partition[ partition_i ].oux.file[ file_i_ ].uid > uid )
        {   if( file_i_ == min )
                return ~0;
            max = file_i_ - 1;
            file_i_ = max - ( file_i_ - min ) / 2;
        }else
        {   if( file_i_ == max )
                return ~0;
            min = file_i_ + 1;
            file_i_ = min + ( max - file_i_ ) / 2;
        }
    }
    *file_i = file_i_;
    return 0;
}
//------------------------------------------------------------------------------
_internal
N
E_ouxfs_Q_block_table_I_unite( I disc_id
, N partition_i
, N64 *block_start
, N64 *block_n
, N64 free_table_found_i
, N64 size_left
, S64 *block_table_diff
){  bool free_table_found_fit = !size_left;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    struct E_ouxfs_Z_block block = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ];
    G( "size_left: %x", size_left );
    G( "free block: type: %8x, sector: %x", block.location_type, block.sector );
    if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        G( "n: %x, pre: %16x, post: %16x", block.location.sectors.n, block.location.sectors.pre, block.location.sectors.post );
    else
        G( "start: %16x, size: %16x", block.location.in_sector.start, block.location.in_sector.size );
    if( size_left )
        if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if( block.location.sectors.post > size_left )
                block.location.sectors.post -= size_left;
            else
            {   size_left -= block.location.sectors.post;
                if( block.location.sectors.n * disc->sata_ahci.physical_sector_size > size_left )
                {   block.location.sectors.n -= size_left / disc->sata_ahci.physical_sector_size;
                    if( size_left % disc->sata_ahci.physical_sector_size )
                    {   block.location.sectors.n--;
                        block.location.sectors.post = disc->sata_ahci.physical_sector_size - size_left % disc->sata_ahci.physical_sector_size;
                        if( !block.location.sectors.n
                        && !block.location.sectors.pre
                        )
                        {   N16 post = block.location.sectors.post;
                            block.location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            block.location.in_sector.start = 0;
                            block.location.in_sector.size = post;
                        }
                    }else
                    {   block.location.sectors.post = 0;
                        if( !block.location.sectors.n )
                        {   N16 pre = block.location.sectors.pre;
                            block.sector--;
                            block.location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            block.location.in_sector.start = disc->sata_ahci.physical_sector_size - pre;
                            block.location.in_sector.size = pre - size_left;
                        }
                    }
                }else
                {   size_left -= block.location.sectors.n * disc->sata_ahci.physical_sector_size;
                    N16 pre = block.location.sectors.pre;
                    block.sector--;
                    block.location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                    block.location.in_sector.start = disc->sata_ahci.physical_sector_size - pre;
                    block.location.in_sector.size = pre - size_left;
                }
            }
        }else
            block.location.in_sector.size -= size_left;
    G( "block 1: type: %8x, sector: %x", block.location_type, block.sector );
    if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        G( "n: %x, pre: %16x, post: %16x", block.location.sectors.n, block.location.sectors.pre, block.location.sectors.post );
    else
        G( "start: %16x, size: %16x", block.location.in_sector.start, block.location.in_sector.size );
    N64 block_table_i;
    N64 upper_block_table_i = ~0;
    bool realloc_subtract, realloc_add;
    if( *block_n )
    {   N64 block_start_ = block_start ? *block_start : 0;
        if( free_table_found_fit )
            for( N64 block_table_i = block_start_; block_table_i != block_start_ + *block_n; block_table_i++ )
                if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                    {   if(( block.sector + block.location.sectors.n == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector - 1
                          && block.location.sectors.post + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre == disc->sata_ahci.physical_sector_size
                        )
                        || block.sector + block.location.sectors.n == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        )
                        {   if( block.sector + block.location.sectors.n == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector - 1 )
                                block.location.sectors.n++;
                            block.location.sectors.n += disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n;
                            block.location.sectors.post = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                            upper_block_table_i = block_table_i;
                            break;
                        }
                    }else
                    {   if( block.sector + block.location.sectors.n == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        && block.location.sectors.post == disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                        )
                        {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size )
                                block.location.sectors.post += disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            else
                            {   block.location.sectors.n++;
                                block.location.sectors.post = 0;
                            }
                            upper_block_table_i = block_table_i;
                            break;
                        }
                    }
                else
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                    {   if( block.sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector - 1
                        && block.location.in_sector.start + block.location.in_sector.size + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre == disc->sata_ahci.physical_sector_size
                        )
                        {   N16 start = block.location.in_sector.start;
                            N16 size = block.location.in_sector.size;
                            block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                            block.location.sectors.n = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n;
                            if(start)
                            {   block.sector++;
                                block.location.sectors.pre = size + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                            }else
                            {   block.location.sectors.n++;
                                block.location.sectors.pre = 0;
                            }
                            block.location.sectors.post = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                            upper_block_table_i = block_table_i;
                            break;
                        }
                    }else
                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector == block.sector
                        && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start == block.location.in_sector.start + block.location.in_sector.size
                        )
                        {   if( block.location.in_sector.size + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size )
                                block.location.in_sector.size += disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            else
                            {   block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                                block.location.sectors.n = 1;
                                block.location.sectors.pre = block.location.sectors.post = 0;
                            }
                            upper_block_table_i = block_table_i;
                            break;
                        }
        for( block_table_i = block_start_; block_table_i != block_start_ + *block_n; block_table_i++ )
            if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n == block.sector - 1
                    && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post + block.location.sectors.pre == disc->sata_ahci.physical_sector_size
                    )
                    {   block.location.sectors.n += disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n + 1;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                        block.sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                        break;
                    }else if( block_table_i + 1 != block_start_ + *block_n
                    && disc->partition[ partition_i ].oux.block_table[ block_table_i + 1 ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i + 1 ].location.sectors.n == block.sector
                    )
                    {   block_table_i++;
                        block.location.sectors.n += disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                        block.sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                        break;
                    }
                }else
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector == block.sector - 1
                    && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size + block.location.sectors.pre == disc->sata_ahci.physical_sector_size
                    )
                    {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start )
                            block.location.sectors.pre += disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                        else
                        {   block.sector--;
                            block.location.sectors.n++;
                            block.location.sectors.pre = 0;
                        }
                        break;
                    }
            }else
                if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n == block.sector - 1
                    && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post + block.location.in_sector.size == disc->sata_ahci.physical_sector_size
                    )
                    {   block.sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                        block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                        block.location.sectors.n = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n + 1;
                        block.location.sectors.post = 0;
                        break;
                    }
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n == block.sector
                    && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post == block.location.in_sector.start
                    )
                    {   block.sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                        N16 size = block.location.in_sector.size;
                        block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                        block.location.sectors.n = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n;
                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post + size != disc->sata_ahci.physical_sector_size )
                            block.location.sectors.post = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post + size;
                        else
                        {   block.location.sectors.n++;
                            block.location.sectors.post = 0;
                        }
                        break;
                    }
                }else
                {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector == block.sector - 1
                    && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size == disc->sata_ahci.physical_sector_size
                    && !block.location.in_sector.start
                    )
                    {   N16 size = block.location.in_sector.size;
                        block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                        block.location.sectors.n = 0;
                        block.location.sectors.post = size;
                        break;
                    }
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector == block.sector
                    && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size == block.location.in_sector.start
                    )
                    {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size + block.location.in_sector.size != disc->sata_ahci.physical_sector_size )
                        {   block.location.in_sector.start -= disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            block.location.in_sector.size += disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                        }else
                        {   block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                            block.location.sectors.n = 1;
                            block.location.sectors.pre = block.location.sectors.post = 0;
                        }
                        break;
                    }
                }
        G( "block 2: type: %u, sector: %x", block.location_type, block.sector );
        if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", block.location.sectors.n, block.location.sectors.pre, block.location.sectors.post );
        else
            G( "start: %16x, size: %16x", block.location.in_sector.start, block.location.in_sector.size );
        if( ~upper_block_table_i
        && block_table_i != block_start_ + *block_n
        )
            realloc_subtract = yes;
        else if( ~upper_block_table_i
        || block_table_i != block_start_ + *block_n
        )
        {   if( ~upper_block_table_i )
                block_table_i = upper_block_table_i;
            realloc_subtract = no;
            realloc_add = no;
        }else
        {   realloc_subtract = no;
            realloc_add = yes;
        }
    }else
    {   realloc_subtract = no;
        realloc_add = yes;
        if( block_start )
            *block_start = block_table_i = disc->partition[ partition_i ].oux.block_table_n;
        else
            block_table_i = 0;
    }
    N r = 0;
    if( realloc_subtract )
    {   *block_table_diff -= sizeof( N64 ) + 1
        + ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
          ? sizeof( N64 ) + sizeof( N16 ) + sizeof( N16 )
          : sizeof( N16 ) + sizeof( N16 )
        );
        if( disc->partition[ partition_i ].oux.block_table_changed_from > block_table_i )
            disc->partition[ partition_i ].oux.block_table_changed_from = block_table_i;
        if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.block_table, block_table_i, disc->partition[ partition_i ].oux.block_table_n - ( block_table_i + 1 )))
            r = ~0;
        if( block_table_i + 1 != disc->partition[ partition_i ].oux.block_table_n )
        {   if( disc->partition[ partition_i ].oux.block_table_directory_table_start > block_table_i )
                disc->partition[ partition_i ].oux.block_table_directory_table_start--;
            if( disc->partition[ partition_i ].oux.block_table_file_table_start > block_table_i )
                disc->partition[ partition_i ].oux.block_table_file_table_start--;
            for_n( file_i, disc->partition[ partition_i ].oux.file_n )
                if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.start > block_table_i )
                    disc->partition[ partition_i ].oux.file[ file_i ].block_table.start--;
        }
        (*block_n)--;
        disc->partition[ partition_i ].oux.block_table_n--;
        block_table_i = upper_block_table_i > block_table_i ? upper_block_table_i - 1 : upper_block_table_i;
        *block_table_diff -= sizeof( N64 ) + 1
        + ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
          ? sizeof( N64 ) + sizeof( N16 ) + sizeof( N16 )
          : sizeof( N16 ) + sizeof( N16 )
        );
        *block_table_diff += sizeof( N64 ) + 1
        + ( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors
          ? sizeof( N64 ) + sizeof( N16 ) + sizeof( N16 )
          : sizeof( N16 ) + sizeof( N16 )
        );
    }else if( realloc_add )
    {   if( !E_mem_Q_blk_I_insert( &disc->partition[ partition_i ].oux.block_table, block_table_i, disc->partition[ partition_i ].oux.block_table_n - 1 - block_table_i ))
            return ~0;
        disc->partition[ partition_i ].oux.block_table_n++;
        (*block_n)++;
        if( block_table_i != disc->partition[ partition_i ].oux.block_table_n - 1 )
        {   if( disc->partition[ partition_i ].oux.block_table_directory_table_start >= block_table_i )
                disc->partition[ partition_i ].oux.block_table_directory_table_start++;
            if( disc->partition[ partition_i ].oux.block_table_file_table_start >= block_table_i )
                disc->partition[ partition_i ].oux.block_table_file_table_start++;
            for_n( file_i, disc->partition[ partition_i ].oux.file_n )
                if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.start >= block_table_i )
                    disc->partition[ partition_i ].oux.file[ file_i ].block_table.start++;
        }
        *block_table_diff += sizeof( N64 ) + 1
        + ( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors
          ? sizeof( N64 ) + sizeof( N16 ) + sizeof( N16 )
          : sizeof( N16 ) + sizeof( N16 )
        );
    }
    G( "block 3: type: %u, sector: %x", block.location_type, block.sector );
    if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        G( "n: %x, pre: %16x, post: %16x", block.location.sectors.n, block.location.sectors.pre, block.location.sectors.post );
    else
        G( "start: %16x, size: %16x", block.location.in_sector.start, block.location.in_sector.size );
    disc->partition[ partition_i ].oux.block_table[ block_table_i ] = block;
    if( disc->partition[ partition_i ].oux.block_table_changed_from > block_table_i )
        disc->partition[ partition_i ].oux.block_table_changed_from = block_table_i;
    if( free_table_found_fit )
    {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.free_table, free_table_found_i, disc->partition[ partition_i ].oux.free_table_n - ( free_table_found_i + 1 )))
            r = ~1;
        disc->partition[ partition_i ].oux.free_table_n--;
    }
    return r;
}
_internal
N
E_ouxfs_Q_free_table_I_unite( N disc_id
, N partition_i
, const struct E_ouxfs_Z_block *block_p
){  struct E_ouxfs_Z_block block = *block_p;
    N64 free_table_i;
    bool realloc_subtract, realloc_add;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( disc->partition[ partition_i ].oux.free_table_n )
    {   N64 upper_free_table_i = ~0;
        if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   N64 free_table_i = E_ouxfs_Q_free_table_R( disc_id, partition_i, block.sector + block.location.sectors.n );
            for( ; free_table_i != disc->partition[ partition_i ].oux.free_table_n; free_table_i++ )
            {   if( block.sector + block.location.sectors.n > disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector )
                    break;
                if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                {   if(( block.sector + block.location.sectors.n == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                      && block.location.sectors.post + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre == disc->sata_ahci.physical_sector_size
                    )
                    || block.sector + block.location.sectors.n == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                    )
                    {   if( block.sector + block.location.sectors.n == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1 )
                            block.location.sectors.n++;
                        block.location.sectors.n += disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n;
                        block.location.sectors.post = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post;
                        upper_free_table_i = free_table_i;
                        break;
                    }
                }else
                {   if( block.sector + block.location.sectors.n == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                    && block.location.sectors.post == disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                    )
                    {   if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size )
                            block.location.sectors.post += disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                        else
                        {   block.location.sectors.n++;
                            block.location.sectors.post = 0;
                        }
                        upper_free_table_i = free_table_i;
                        break;
                    }
                }
            }
        }else
        {   N64 free_table_i = E_ouxfs_Q_free_table_R( disc_id, partition_i, block.sector );
            for( ; free_table_i != disc->partition[ partition_i ].oux.free_table_n; free_table_i++ )
            {   if( block.sector > disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector )
                    break;
                if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                {   if( block.sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                    && block.location.in_sector.start + block.location.in_sector.size == disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                    )
                    {   N16 start = block.location.in_sector.start;
                        N16 size = block.location.in_sector.size;
                        block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        block.location.sectors.n = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n;
                        if(start)
                        {   block.sector++;
                            block.location.sectors.pre = size + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre;
                        }else
                        {   block.location.sectors.n++;
                            block.location.sectors.pre = 0;
                        }
                        block.location.sectors.post = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post;
                        upper_free_table_i = free_table_i;
                        break;
                    }
                }else
                {   if( block.sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                    && block.location.in_sector.start + block.location.in_sector.size == disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                    )
                    {   if( block.location.in_sector.size + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size )
                            block.location.in_sector.size += disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                        else
                        {   block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                            block.location.sectors.n = 1;
                            block.location.sectors.pre = block.location.sectors.post = 0;
                        }
                        upper_free_table_i = free_table_i;
                        break;
                    }
                    if( block.sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                    && block.location.in_sector.start + block.location.in_sector.size == disc->sata_ahci.physical_sector_size
                    && !disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                    )
                    {   N16 size = block.location.in_sector.size;
                        block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        block.location.sectors.n = 0;
                        block.location.sectors.pre = size;
                        block.location.sectors.post = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                        upper_free_table_i = free_table_i;
                        break;
                    }
                }
            }
        }
        bool lower = no;
        N64 free_table_start, free_table_end;
        if( !~upper_free_table_i )
        {   free_table_start = E_ouxfs_Q_free_table_R( disc_id, partition_i, block.sector );
            if( free_table_start == disc->partition[ partition_i ].oux.free_table_n )
                free_table_start--;
            free_table_end = ~0;
        }else
        {   free_table_start = free_table_end = upper_free_table_i - 1;
            if( upper_free_table_i )
                free_table_end--;
        }
        if( block.location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            for( free_table_i = free_table_start; free_table_i != free_table_end; free_table_i-- )
                if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                {   if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n < block.sector - 1 )
                        break;
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n == block.sector - 1
                    && disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post + block.location.sectors.pre == disc->sata_ahci.physical_sector_size
                    )
                    {   block.sector = disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector;
                        block.location.sectors.n += disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n + 1;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre;
                        lower = yes;
                        break;
                    }else if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n == block.sector )
                    {   block.sector = disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector;
                        block.location.sectors.n += disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre;
                        lower = yes;
                        break;
                    }
                }else
                {   if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector < block.sector - 1 )
                        break;
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector == block.sector - 1
                    && disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size == disc->sata_ahci.physical_sector_size - block.location.sectors.pre
                    )
                    {   if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start )
                            block.location.sectors.pre += disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                        else
                        {   block.sector--;
                            block.location.sectors.n++;
                            block.location.sectors.pre = 0;
                        }
                        lower = yes;
                        break;
                    }
                }
        else
        {   if( !~upper_free_table_i )
            {   while( free_table_start != disc->partition[ partition_i ].oux.free_table_n - 1
                && disc->partition[ partition_i ].oux.free_table[ free_table_start ].sector == block.sector
                )
                    free_table_start++;
                if( disc->partition[ partition_i ].oux.free_table[ free_table_start ].sector != block.sector )
                    free_table_start--;
            }
            for( free_table_i = free_table_start; free_table_i != free_table_end; free_table_i-- )
                if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                {   if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n < block.sector )
                        break;
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n == block.sector
                    && disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post == block.location.in_sector.start
                    )
                    {   N16 size = block.location.in_sector.size;
                        block.sector = disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector;
                        block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        block.location.sectors.n = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre;
                        if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post + size != disc->sata_ahci.physical_sector_size )
                            block.location.sectors.post = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post + size;
                        else
                        {   block.location.sectors.n++;
                            block.location.sectors.post = 0;
                        }
                        lower = yes;
                        break;
                    }
                }else
                {   if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector < block.sector - 1 )
                        break;
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector == block.sector
                    && disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size == block.location.in_sector.start
                    )
                    {   if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size + block.location.in_sector.size != disc->sata_ahci.physical_sector_size )
                        {   block.location.in_sector.start = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start;
                            block.location.in_sector.size += disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                        }else
                        {   block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                            block.location.sectors.n = 1;
                            block.location.sectors.pre = block.location.sectors.post = 0;
                        }
                        lower = yes;
                        break;
                    }
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector == block.sector - 1
                    && disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size == disc->sata_ahci.physical_sector_size
                    && !block.location.in_sector.start
                    )
                    {   N16 size = block.location.in_sector.size;
                        block.location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        block.location.sectors.n = 0;
                        block.location.sectors.pre = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                        block.location.sectors.post = size;
                        lower = yes;
                        break;
                    }
                }
        }
        if( ~upper_free_table_i
        && lower
        )
            realloc_subtract = yes;
        else if( ~upper_free_table_i
        || lower
        )
        {   if( ~upper_free_table_i )
                free_table_i = upper_free_table_i;
            realloc_add = no;
            realloc_subtract = no;
        }else
        {   realloc_add = yes;
            realloc_subtract = no;
            free_table_i = E_ouxfs_Q_free_table_R( disc_id, partition_i, block.sector );
            if( block.location_type == E_ouxfs_Z_block_Z_location_S_in_sector )
            {   while( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector == block.sector
                && free_table_i
                )
                    free_table_i--;
                for( ; free_table_i != disc->partition[ partition_i ].oux.free_table_n; free_table_i++ )
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector > block.sector
                    || ( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector == block.sector
                      && disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_in_sector
                      && disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start > block.location.in_sector.start + block.location.in_sector.size
                    ))
                            break;
            }
        }
    }else
    {   realloc_add = yes;
        realloc_subtract = no;
        free_table_i = 0;
    }
    N r = 0;
    if( realloc_subtract )
    {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.free_table, free_table_i + 1, 1 ))
            return ~0;
        disc->partition[ partition_i ].oux.free_table_n--;
    }else if( realloc_add )
    {   if( !E_mem_Q_blk_I_insert( &disc->partition[ partition_i ].oux.free_table, free_table_i, 1 ))
            return ~0;
        disc->partition[ partition_i ].oux.free_table_n++;
    }
    disc->partition[ partition_i ].oux.free_table[ free_table_i ] = block;
    return r;
}
//------------------------------------------------------------------------------
_internal
N
E_ouxfs_Z_start_n_I_block_truncate( N disc_id
, N partition_i
, N64 n
, N64 block_start
, N64 *block_n
, S64 *block_table_diff
){  *block_table_diff = 0;
    N64 block_table_i;
    bool block_first_use = no;
    struct E_ouxfs_Z_block block_first;
    N64 block_delete_start;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    for( block_table_i = *block_n - 1; ~block_table_i; block_table_i-- )
    {   struct E_ouxfs_Z_block *block = &disc->partition[ partition_i ].oux.block_table[ block_start + block_table_i ];
        if( block->location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   N64 n__ = J_min( n, block->location.sectors.post );
            n -= n__;
            if( !n )
            {   block_delete_start = block_table_i;
                N16 post = block->location.sectors.post;
                block->location.sectors.post -= n__;
                if( n__ != post )
                {   block_first_use = yes;
                    block_first = *block;
                    block_first.sector++;
                    block_first.location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                    block_first.location.in_sector.start = block->location.sectors.post;
                    block_first.location.in_sector.size = post - block_first.location.in_sector.start;
                }else
                {   block_delete_start++;
                    if( !block->location.sectors.n )
                    {   N16 pre = block->location.sectors.pre;
                        block->sector--;
                        block->location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                        block->location.in_sector.start = disc->sata_ahci.physical_sector_size - pre;
                        block->location.in_sector.size = pre;
                        *block_table_diff -= sizeof( N64 );
                    }
                }
                break;
            }
            for_n( sector_i, block->location.sectors.n )
            {   N64 n__ = J_min( n, disc->sata_ahci.physical_sector_size );
                n -= n__;
                if( !n )
                {   block_delete_start = block_table_i;
                    N64 size = block->location.sectors.pre + block->location.sectors.n * disc->sata_ahci.physical_sector_size + block->location.sectors.post;
                    N64 size_left = size
                    - ( block->location.sectors.post
                      + sector_i * disc->sata_ahci.physical_sector_size
                      + n__
                    );
                    if( size_left )
                    {   block_first_use = yes;
                        block_first = *block;
                        block->location.sectors.n -= sector_i + 1;
                        block_first.sector += block->location.sectors.n;
                        block_first.location.sectors.n = sector_i;
                        if( n__ != disc->sata_ahci.physical_sector_size )
                        {   block->location.sectors.post = disc->sata_ahci.physical_sector_size - n__;
                            block_first.location.sectors.pre = disc->sata_ahci.physical_sector_size - block->location.sectors.post;
                            if( !block->location.sectors.n
                            && !block->location.sectors.pre
                            )
                            {   N16 post = block->location.sectors.post;
                                block->location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                block->location.in_sector.start = 0;
                                block->location.in_sector.size = post;
                                *block_table_diff -= sizeof( N64 );
                            }
                            if( !block_first.location.sectors.n
                            && !block_first.location.sectors.post
                            )
                            {   N16 pre = block_first.location.sectors.pre;
                                block_first.location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                block_first.sector--;
                                block_first.location.in_sector.start = disc->sata_ahci.physical_sector_size - pre;
                                block_first.location.in_sector.size = pre;
                            }
                        }else
                        {   block->location.sectors.n++;
                            block->location.sectors.post = 0;
                            block_first.sector--;
                            block_first.location.sectors.n++;
                            block_first.location.sectors.pre = 0;
                        }
                    }
                    goto Loop_end;
                }
            }
            n__ = J_min( n, block->location.sectors.pre );
            n -= n__;
            if( !n )
            {   block_delete_start = block_table_i;
                if( n__ != block->location.sectors.pre )
                {   block_first_use = yes;
                    block_first = *block;
                    N16 pre = block->location.sectors.pre;
                    block->sector--;
                    block->location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                    block->location.in_sector.start = disc->sata_ahci.physical_sector_size - pre;
                    block->location.in_sector.size = pre - n__;
                    block_first.location.sectors.pre -= block->location.in_sector.size;
                    *block_table_diff -= sizeof( N64 );
                }
                break;
            }
        }else
        {   N64 n__ = J_min( n, block->location.in_sector.size );
            n -= n__;
            if( !n )
            {   block_delete_start = block_table_i;
                if( n__ != block->location.in_sector.size )
                {   block_first_use = yes;
                    block_first = *block;
                    block->location.in_sector.size -= n__;
                    block_first.location.in_sector.start += block->location.in_sector.size;
                    block_first.location.in_sector.size = n__;
                }
                break;
            }
        }
    }
    if(n) // Sprawdzenie na czas testów.
        return ~0;
Loop_end:
    if( disc->partition[ partition_i ].oux.block_table_changed_from > block_table_i )
        disc->partition[ partition_i ].oux.block_table_changed_from = block_table_i;
    N r = 0;
    if( block_first_use )
    {   r = E_ouxfs_Q_free_table_I_unite( disc_id, partition_i, &block_first );
        block_delete_start++;
    }
    for( N64 block_table_i = block_delete_start; block_table_i != *block_n; block_table_i++ )
    {   if( !r )
            r = E_ouxfs_Q_free_table_I_unite( disc_id, partition_i, &disc->partition[ partition_i ].oux.block_table[ block_start + block_table_i ] );
        *block_table_diff -= sizeof( N64 ) + 1
        + ( disc->partition[ partition_i ].oux.block_table[ block_start + block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
          ? sizeof( N64 ) + sizeof( N16 ) + sizeof( N16 )
          : sizeof( N16 ) + sizeof( N16 )
        );
    }
    if( !~r )
        G( "some free blocks not counted, remount filesystem: disc_id=%x, partition_i=%x", disc_id, partition_i );
    if( block_delete_start != disc->partition[ partition_i ].oux.block_table_n )
    {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.block_table
        , block_start + block_delete_start
        , disc->partition[ partition_i ].oux.block_table_n - ( block_start + *block_n )
        ))
            return ~0;
        if( disc->partition[ partition_i ].oux.block_table_directory_table_start > block_start + block_delete_start )
            disc->partition[ partition_i ].oux.block_table_directory_table_start -= *block_n - block_delete_start;
        if( disc->partition[ partition_i ].oux.block_table_file_table_start > block_start + block_delete_start )
            disc->partition[ partition_i ].oux.block_table_file_table_start -= *block_n - block_delete_start;
        for_n( file_i, disc->partition[ partition_i ].oux.file_n )
            if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.start > block_start + block_delete_start )
                disc->partition[ partition_i ].oux.file[ file_i ].block_table.start -= *block_n - block_delete_start;
        disc->partition[ partition_i ].oux.block_table_n -= *block_n - block_delete_start;
        *block_n = block_delete_start;
    }
    return r;
}
_internal
N
E_ouxfs_Z_start_n_I_block_append( N disc_id
, N partition_i
, N64 n
, N64 *block_start
, N64 *block_n
, N64 *changed_from
, S64 *block_table_diff
, N64 internal_table_element_size
, N64 *count
){  N64 n_0 = n;
    N r = 0;
    *block_table_diff = 0;
    *count = 0;
    N64 size;
    N64 free_table_found_i;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( *block_n
    && disc->partition[ partition_i ].oux.free_table_n
    )
    {   N64 block_start_ = block_start ? *block_start : 0;
        // Szukaj wolnego bloku na całą tablicę.
        N64 table_size = E_ouxfs_Z_start_n_R_size( disc_id, partition_i, block_start_, *block_n ) + n + internal_table_element_size;
        N64 lowest_size = ~0;
        for_n( free_table_i, disc->partition[ partition_i ].oux.free_table_n )
        {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
            ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
              + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
              + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
            : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
            if( size >= table_size
            && lowest_size > size
            )
            {   lowest_size = size;
                free_table_found_i = free_table_i;
                if( size == table_size )
                    break;
            }
        }
        if( ~lowest_size )
        {   for_n( block_table_i, *block_n )
            {   if( !r
                || r == ~1
                )
                    r = E_ouxfs_Q_free_table_I_unite( disc_id, partition_i, &disc->partition[ partition_i ].oux.block_table[ block_start_ + block_table_i ] );
                *block_table_diff -= sizeof( N64 ) + 1
                + ( disc->partition[ partition_i ].oux.block_table[ block_start_ + block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                  ? sizeof( N64 ) + sizeof( N16 ) + sizeof( N16 )
                  : sizeof( N16 ) + sizeof( N16 )
                );
            }
            if( !~r )
                G( "some free blocks not counted, remount filesystem: disc_id=%x, partition_i=%x", disc_id, partition_i );
            if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.block_table, block_start_, *block_n ))
                return ~0;
            disc->partition[ partition_i ].oux.block_table_n -= *block_n;
            if( disc->partition[ partition_i ].oux.block_table_directory_table_start > block_start_ )
                disc->partition[ partition_i ].oux.block_table_directory_table_start -= *block_n;
            if( disc->partition[ partition_i ].oux.block_table_file_table_start > block_start_ )
                disc->partition[ partition_i ].oux.block_table_file_table_start -= *block_n;
            for_n( file_i, disc->partition[ partition_i ].oux.file_n )
                if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.start > block_start_ )
                    disc->partition[ partition_i ].oux.file[ file_i ].block_table.start -= *block_n;
            *block_n = 0;
            *changed_from = 0;
            N64 lowest_size = ~0;
            for_n( free_table_i, disc->partition[ partition_i ].oux.free_table_n )
            {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                  + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                  + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
                : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                if( size >= table_size
                && lowest_size > size
                )
                {   lowest_size = size;
                    free_table_found_i = free_table_i;
                    if( size == table_size )
                        break;
                }
            }
            n = table_size;
            size = lowest_size;
            goto Compute;
        }
        // Szukaj wolnego bloku przyległego od góry do ostatniego przydzielonego.
        free_table_i = E_ouxfs_Q_free_table_R( disc_id, partition_i, disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector + 1 );
        if( free_table_i == disc->partition[ partition_i ].oux.free_table_n )
            free_table_i--;
        if( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            for( ; ~free_table_i; free_table_i-- )
            {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                  + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                  + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
                : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                  < disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector
                  + disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.n
                )
                    break;
                if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                {   if(( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector
                        + disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.n
                        == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                      && disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.post
                        + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                        == disc->sata_ahci.physical_sector_size
                    )
                    || ( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector
                        + disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.n
                        == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                      && !disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.post
                      && !disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                    ))
                    {   free_table_found_i = free_table_i;
                        (*count)--;
                        goto Compute;
                    }
                }else
                {   if(( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector
                        + disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.n
                        == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                      && disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.post == disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                    )
                    || ( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector
                        + disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.n
                        == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                      && !disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.sectors.post
                      && !disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                    ))
                    {   free_table_found_i = free_table_i;
                        (*count)--;
                        goto Compute;
                    }
                }
            }
        else
        {   while( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector == disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector + 1
            && free_table_i != disc->partition[ partition_i ].oux.free_table_n - 1
            )
                free_table_i++;
            for( ; ~free_table_i; free_table_i-- )
            {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                  + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                  + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
                : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector < disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector )
                    break;
                if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                {   if( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                    && ( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.in_sector.start
                      + disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.in_sector.size
                      == disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                    ))
                    {   free_table_found_i = free_table_i;
                        (*count)--;
                        goto Compute;
                    }
                }else
                {   if(( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                      && disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.in_sector.start
                        + disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.in_sector.size
                        == disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                    )
                    || ( disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                      && disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.in_sector.start
                        + disc->partition[ partition_i ].oux.block_table[ block_start_ + *block_n - 1 ].location.in_sector.size
                        == disc->sata_ahci.physical_sector_size
                      && !disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                    ))
                    {   free_table_found_i = free_table_i;
                        (*count)--;
                        goto Compute;
                    }
                }
            }
        }
    }
    n += internal_table_element_size;
    // Szukaj wolnego bloku na całe żądane dopisywane dane.
    N64 lowest_size = ~0;
    for_n( free_table_i, disc->partition[ partition_i ].oux.free_table_n )
    {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
          ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
            + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
            + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
          : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
        if( size >= n
        && lowest_size > size
        )
        {   lowest_size = size;
            free_table_found_i = free_table_i;
            if( size == n )
                break;
        }
    }
    if( ~lowest_size )
    {   size = lowest_size;
        goto Compute;
    }
    O{  if( !disc->partition[ partition_i ].oux.free_table_n )
        {   G( "no space left on device: %x", n );
            return ~0;
        }
        // Szukaj największego wolnego bloku mniejszego od żądanych dopisywanych danych.
        N64 greatest_size = 0;
        for_n( free_table_i, disc->partition[ partition_i ].oux.free_table_n )
        {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
            ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
              + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
              + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
            : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
            if( greatest_size < size )
            {   if( size >= n )
                    break;
                greatest_size = size;
                free_table_found_i = free_table_i;
            }
        }
        if( free_table_i == disc->partition[ partition_i ].oux.free_table_n )
            size = greatest_size;
        else
        {   // Szukaj wolnego bloku na całe żądane dopisywane dane.
            N64 lowest_size = ~0;
            for_n( free_table_i, disc->partition[ partition_i ].oux.free_table_n )
            {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                  + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                  + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
                : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                if( size >= n
                && lowest_size > size
                )
                {   lowest_size = size;
                    free_table_found_i = free_table_i;
                    if( size == n )
                        break;
                }
            }
            size = lowest_size;
        }
Compute:(*count)++;
        N64 n__;
        if( disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if( disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre )
            {   n__ = J_min( n, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre );
                n -= n__;
                if( !n )
                {   N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
                    , block_start, block_n
                    , free_table_found_i, size - n__
                    , block_table_diff
                    );
                    if( r_ )
                    {   r = r_;
                        r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                        , n_0 - ( n + n__ )
                        , *block_start, block_n
                        , block_table_diff
                        );
                        if( r_ )
                            r = r_;
                    }else
                    {   disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre -= n__;
                        if( !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre
                        && !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n
                        )
                        {   N16 post = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post;
                            disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start = 0;
                            disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size = post;
                        }
                    }
                    break;
                }
            }
            for_n( sector_i, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n )
            {   n__ = J_min( n, disc->sata_ahci.physical_sector_size );
                n -= n__;
                if( !n )
                {   N64 size_left = size
                    - ( disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre
                      + sector_i * disc->sata_ahci.physical_sector_size
                      + n__
                    );
                    N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
                    , block_start, block_n
                    , free_table_found_i, size_left
                    , block_table_diff
                    );
                    if( r_ )
                    {   r = r_;
                        r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                        , n_0 - ( n + n__ )
                        , *block_start, block_n
                        , block_table_diff
                        );
                        if( r_ )
                            r = r_;
                    }else if( size_left )
                    {   N16 post = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector += sector_i + 1;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n -= sector_i + 1;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre = disc->sata_ahci.physical_sector_size - n__;
                        if( !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n )
                            if( !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post )
                            {   N16 pre = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector--;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start = disc->sata_ahci.physical_sector_size - pre;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size = pre;
                            }else if( !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre )
                            {   disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start = 0;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size = post;
                            }
                    }
                    return r;
                }
            }
            if( disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post )
            {   n__ = J_min( n, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post );
                n -= n__;
                if( !n )
                {   N16 post = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post;
                    N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
                    , block_start, block_n
                    , free_table_found_i, post - n__
                    , block_table_diff
                    );
                    if( r_ )
                    {   r = r_;
                        r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                        , n_0 - ( n + n__ )
                        , *block_start, block_n
                        , block_table_diff
                        );
                        if( r_ )
                            r = r_;
                    }else if( post != n__ )
                    {   disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector += disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start = n__;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size = post - disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start;
                    }
                    break;
                }
            }
        }else
        {   n__ = J_min( n, size );
            n -= n__;
            if( !n )
            {   N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
                , block_start, block_n
                , free_table_found_i, size - n__
                , block_table_diff
                );
                if( r_ )
                {   r = r_;
                    r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                    , n_0 - ( n + n__ )
                    , *block_start, block_n
                    , block_table_diff
                    );
                    if( r_ )
                        r = r_;
                }else if( size != n__ )
                {   disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start += n__;
                    disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size -= n__;
                }
                break;
            }
        }
        N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
        , block_start, block_n
        , free_table_found_i, 0
        , block_table_diff
        );
        if( r_ )
            r = r_;
        else
        {   r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
            , n_0 - ( n + n__ )
            , *block_start, block_n
            , block_table_diff
            );
            if( r_ )
                r = r_;
            break;
        }
        n += internal_table_element_size;
    }
    return r;
}
_internal
N
E_ouxfs_Q_block_table_I_append_truncate( N disc_id
, N partition_i
, S64 block_table_diff
){  N r = 0;
    G( "block_table_diff: %lld", block_table_diff );
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( block_table_diff > 0 )
    {   if( disc->partition[ partition_i ].oux.block_table_size + block_table_diff > disc->partition[ partition_i ].oux.first_sector_max_size )
        {   S64 block_table_diff_above = disc->partition[ partition_i ].oux.block_table_size > disc->partition[ partition_i ].oux.first_sector_max_size
            ? block_table_diff
            : disc->partition[ partition_i ].oux.block_table_size + block_table_diff - disc->partition[ partition_i ].oux.first_sector_max_size;
            S64 block_table_diff_;
            N64 count;
            N64 internal_table_element_size = sizeof( N64 ) + 1 + sizeof( N64 ) + sizeof( N16 ) + sizeof( N16 );
            r = E_ouxfs_Z_start_n_I_block_append( disc_id, partition_i
            , block_table_diff_above
            , 0, &disc->partition[ partition_i ].oux.block_table_block_table_n
            , &disc->partition[ partition_i ].oux.block_table_changed_from
            , &block_table_diff_
            , internal_table_element_size
            , &count
            );
            if(r)
                return r;
            G( "block_table_diff_above: %lld", block_table_diff_above );
            G( "block_table_diff_: %lld", block_table_diff_ );
            block_table_diff_ = count * internal_table_element_size - block_table_diff_;
            G( "block_table_diff_: %lld", block_table_diff_ );
            if( block_table_diff_ )
            {   S64 block_table_diff__;
                block_table_diff_above = disc->partition[ partition_i ].oux.block_table_size + block_table_diff + count * internal_table_element_size - block_table_diff_ > disc->partition[ partition_i ].oux.first_sector_max_size
                ? block_table_diff_
                : disc->partition[ partition_i ].oux.block_table_size + block_table_diff + count * internal_table_element_size - disc->partition[ partition_i ].oux.first_sector_max_size;
                G( "block_table_diff_above: %lld", block_table_diff_above );
                N r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                , block_table_diff_above
                , 0, &disc->partition[ partition_i ].oux.block_table_block_table_n
                , &block_table_diff__
                );
                if( r_ )
                    r = r_;
                while( block_table_diff__ )
                {   block_table_diff_above = disc->partition[ partition_i ].oux.block_table_size + block_table_diff - block_table_diff_ + block_table_diff__ > disc->partition[ partition_i ].oux.first_sector_max_size
                    ? -block_table_diff__
                    : disc->partition[ partition_i ].oux.block_table_size + block_table_diff - block_table_diff_ - disc->partition[ partition_i ].oux.first_sector_max_size;
                    disc->partition[ partition_i ].oux.block_table_size += block_table_diff__;
                    G( "block_table_diff_above: %lld", block_table_diff_above );
                    if( block_table_diff_above <= 0 )
                        break;
                    N r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                    , block_table_diff_above
                    , 0, &disc->partition[ partition_i ].oux.block_table_block_table_n
                    , &block_table_diff__
                    );
                    if( r_ )
                        r = r_;
                }
            }
            disc->partition[ partition_i ].oux.block_table_size -= block_table_diff_;
        }
    }else if( block_table_diff < 0 )
        if( disc->partition[ partition_i ].oux.block_table_size > disc->partition[ partition_i ].oux.first_sector_max_size )
        {   S64 block_table_diff__;
            N r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
            , disc->partition[ partition_i ].oux.block_table_size + block_table_diff > disc->partition[ partition_i ].oux.first_sector_max_size
              ? -block_table_diff
              : disc->partition[ partition_i ].oux.block_table_size - disc->partition[ partition_i ].oux.first_sector_max_size
            , 0, &disc->partition[ partition_i ].oux.block_table_block_table_n
            , &block_table_diff__
            );
            if( r_ )
                r = r_;
            while( block_table_diff__ )
            {   S64 block_table_diff_above = disc->partition[ partition_i ].oux.block_table_size + block_table_diff + block_table_diff__ > disc->partition[ partition_i ].oux.first_sector_max_size
                ? -block_table_diff__
                : disc->partition[ partition_i ].oux.block_table_size + block_table_diff - disc->partition[ partition_i ].oux.first_sector_max_size;
                disc->partition[ partition_i ].oux.block_table_size += block_table_diff__;
                if( block_table_diff_above <= 0 )
                    break;
                N r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i, block_table_diff_above
                , 0, &disc->partition[ partition_i ].oux.block_table_block_table_n
                , &block_table_diff__
                );
                if( r_ )
                    r = r_;
            }
        }
    disc->partition[ partition_i ].oux.block_table_size += block_table_diff;
    G( "block_table_size: %x", disc->partition[ partition_i ].oux.block_table_size );
    return r;
}
_internal
N
E_ouxfs_Q_directory_file_I_block_append( N disc_id
, N partition_i
, N64 n
, N64 *block_start
, N64 *block_n
, N64 *changed_from
){  S64 block_table_diff;
    N64 count;
    /*G( "1" );
    for_n( i, disc->partition[ partition_i ].oux.free_table_n )
    {   G( "%x. type: %u, sector: %x", i, disc->partition[ partition_i ].oux.free_table[i].location_type, disc->partition[ partition_i ].oux.free_table[i].sector );
        if( disc->partition[ partition_i ].oux.free_table[i].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.free_table[i].location.sectors.n, disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre, disc->partition[ partition_i ].oux.free_table[i].location.sectors.post );
        else
            G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start, disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size );
    }
    for_n( block_table_i, disc->partition[ partition_i ].oux.block_table_n )
    {   G( "block_table_i: %x, sector: %x", block_table_i, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector );
        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post );
        else
            G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
    }*/
    N r = E_ouxfs_Z_start_n_I_block_append( disc_id, partition_i
    , n
    , block_start, block_n
    , changed_from
    , &block_table_diff
    , 0, &count
    );
    if(r)
        return r;
    N r_ = E_ouxfs_Q_block_table_I_append_truncate( disc_id, partition_i, block_table_diff );
    if( r_ )
    {   r = r_;
        r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
        , n
        , *block_start, block_n
        , &block_table_diff
        );
        if( r_ )
            r = r_;
    }
    /*G( "2" );
    for_n( i, disc->partition[ partition_i ].oux.free_table_n )
    {   G( "%x. type: %u, sector: %x", i, disc->partition[ partition_i ].oux.free_table[i].location_type, disc->partition[ partition_i ].oux.free_table[i].sector );
        if( disc->partition[ partition_i ].oux.free_table[i].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.free_table[i].location.sectors.n, disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre, disc->partition[ partition_i ].oux.free_table[i].location.sectors.post );
        else
            G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start, disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size );
    }
    for_n( block_table_i, disc->partition[ partition_i ].oux.block_table_n )
    {   G( "block_table_i: %x, sector: %x", block_table_i, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector );
        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post );
        else
            G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
    }*/
    return r;
}
_internal
N
E_ouxfs_Q_directory_file_I_block_append_truncate( N disc_id
, N partition_i
, long n_prev
, const char *name
, N64 *block_start
, N64 *block_n
, N64 *changed_from
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    N64 n = E_text_Z_s0_R_l_0(name);
    if( n > n_prev )
        r = E_ouxfs_Q_directory_file_I_block_append( disc_id, partition_i, n - n_prev, block_start, block_n, changed_from );
    else if( n < n_prev )
    {   S64 block_table_diff__;
        r = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i, n_prev - n, *block_start, block_n, &block_table_diff__ );
        while( block_table_diff__ )
        {   S64 block_table_diff_above = disc->partition[ partition_i ].oux.block_table_size + block_table_diff__ > disc->partition[ partition_i ].oux.first_sector_max_size
            ? -block_table_diff__
            : disc->partition[ partition_i ].oux.block_table_size - disc->partition[ partition_i ].oux.first_sector_max_size;
            disc->partition[ partition_i ].oux.block_table_size += block_table_diff__;
            if( block_table_diff_above <= 0 )
                break;
            N r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
            , block_table_diff_above
            , 0, &disc->partition[ partition_i ].oux.block_table_block_table_n
            , &block_table_diff__
            );
            if( r_ )
                r = r_;
        }
    }
    return r;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define E_ouxfs_Q_device_I_switch_item( type, item, end ) \
    if( data_i ) \
    {   do \
        {   item |= (type)*data++ << data_i++ * 8; \
        }while( data_i != sizeof(type) \
        && data != (end) \
        ); \
        if( data_i == sizeof(type) ) \
            data_i = 0; \
        else \
            break; \
    }else \
    {   if( data == (end) ) \
            break; \
        if( data + sizeof(type) > (end) ) \
        {   item = 0; \
            do \
            {   item |= (type)*data++ << data_i++ * 8; \
            }while( data != (end) ); \
            break; \
        } \
        item = *( type * )data; \
        data += sizeof(type); \
    } \
    continue_from++
//------------------------------------------------------------------------------
_private
N
E_ouxfs_Q_device_M( I disc_id
, N partition_i
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N r_;
    Pc sector;
    if( E_disc_I_read( disc_id, partition_i, 0, 1, &sector, &r_ ))
    {   G( "read sector: 0" );
        E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
        r = ~0;
        goto End;
    }
    if( !E_text_Z_sl_T_eq( sector, E_ouxfs_Q_device_S_ident, J_s0_R_l( E_ouxfs_Q_device_S_ident )))
    {   G( "no filesystem identification string" );
        E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
        r = ~0;
        goto End;
    }
    N64 *block_table_n = (P)E_simple_Z_p_I_align_up_to_v2( sector + J_s0_R_l( E_ouxfs_Q_device_S_ident ), sizeof( N64 ));
    disc->partition[ partition_i ].oux.block_table_n = block_table_n[0];
    disc->partition[ partition_i ].oux.block_table_block_table_n = block_table_n[1];
    disc->partition[ partition_i ].oux.block_table_directory_table_start = block_table_n[2];
    disc->partition[ partition_i ].oux.block_table_directory_table_n = block_table_n[3];
    disc->partition[ partition_i ].oux.block_table_file_table_start = block_table_n[4];
    disc->partition[ partition_i ].oux.block_table_file_table_n = block_table_n[5];
    if( disc->partition[ partition_i ].oux.block_table_n < disc->partition[ partition_i ].oux.block_table_block_table_n
    || ( disc->partition[ partition_i ].oux.block_table_directory_table_n
      && ( disc->partition[ partition_i ].oux.block_table_n < disc->partition[ partition_i ].oux.block_table_directory_table_start + disc->partition[ partition_i ].oux.block_table_directory_table_n
        || disc->partition[ partition_i ].oux.block_table_block_table_n > disc->partition[ partition_i ].oux.block_table_directory_table_start
    ))
    || ( disc->partition[ partition_i ].oux.block_table_file_table_n
      && ( disc->partition[ partition_i ].oux.block_table_n < disc->partition[ partition_i ].oux.block_table_file_table_start + disc->partition[ partition_i ].oux.block_table_file_table_n
        || disc->partition[ partition_i ].oux.block_table_block_table_n > disc->partition[ partition_i ].oux.block_table_file_table_start
    ))
    || ( disc->partition[ partition_i ].oux.block_table_directory_table_n
      && disc->partition[ partition_i ].oux.block_table_file_table_n
      && (( disc->partition[ partition_i ].oux.block_table_directory_table_start >= disc->partition[ partition_i ].oux.block_table_file_table_start
          && disc->partition[ partition_i ].oux.block_table_directory_table_start < disc->partition[ partition_i ].oux.block_table_file_table_start + disc->partition[ partition_i ].oux.block_table_file_table_n
        )
        || ( disc->partition[ partition_i ].oux.block_table_directory_table_start < disc->partition[ partition_i ].oux.block_table_file_table_start
          && disc->partition[ partition_i ].oux.block_table_directory_table_start + disc->partition[ partition_i ].oux.block_table_directory_table_n > disc->partition[ partition_i ].oux.block_table_file_table_start
        )
        || ( disc->partition[ partition_i ].oux.block_table_file_table_start >= disc->partition[ partition_i ].oux.block_table_directory_table_start
          && disc->partition[ partition_i ].oux.block_table_file_table_start < disc->partition[ partition_i ].oux.block_table_directory_table_start + disc->partition[ partition_i ].oux.block_table_directory_table_n
        )
        || ( disc->partition[ partition_i ].oux.block_table_file_table_start < disc->partition[ partition_i ].oux.block_table_directory_table_start
          && disc->partition[ partition_i ].oux.block_table_file_table_start + disc->partition[ partition_i ].oux.block_table_file_table_n > disc->partition[ partition_i ].oux.block_table_directory_table_start
    ))))
    {   G( "filesystem header inconsistent" );
        E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
        r = ~0;
        goto End;
    }
    Pc data = ( void * )&block_table_n[6];
    disc->partition[ partition_i ].oux.first_sector_max_size = disc->sata_ahci.physical_sector_size - ( N16 )(( Pc  )&block_table_n[6] - sector );
    Mt_( disc->partition[ partition_i ].oux.block_table, disc->partition[ partition_i ].oux.block_table_n );
    if( !disc->partition[ partition_i ].oux.block_table )
    {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
        r = ~0;
        goto End;
    }
    disc->partition[ partition_i ].oux.block_table_size = 0;
    // Odczyt tablicy bloków do pamięci operacyjnej.
    N continue_from = ~0;
    N data_i = 0;
    N64 block_table_i = ~0;
    do // Czyta wpisy pliku tablicy bloków znajdujące się w pierwszym sektorze.
    {   switch( continue_from )
        { case ~0:
                block_table_i++;
                if( block_table_i == disc->partition[ partition_i ].oux.block_table_n )
                    goto End_loop;
                continue_from++;
          case 0:
                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                , sector + disc->sata_ahci.physical_sector_size
                );
                disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
          default:
                if( continue_from == 1 )
                {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                    , sector + disc->sata_ahci.physical_sector_size
                    );
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_sectors
                    && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_in_sector
                    )
                    {   G( "location type unknown: block_table_i=%x", block_table_i );
                        E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                        r = ~0;
                        goto End_1;
                    }
                    disc->partition[ partition_i ].oux.block_table_size++;
                }
                if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                    switch( continue_from )
                    { case 2:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                      case 3:
                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre >= disc->sata_ahci.physical_sector_size )
                            {   G( "pre not less than sector: block_table_i=%x", block_table_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_1;
                            }
                            disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                      case 4:
                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post >= disc->sata_ahci.physical_sector_size )
                            {   G( "post not less than sector: block_table_i=%x", block_table_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_1;
                            }
                            if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                            && ( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                || !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                            ))
                            {   G( "sectors and pre or post 0: block_table_i=%x", block_table_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_1;
                            }
                            disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                            continue_from = ~0;
                    }
                else
                    switch( continue_from )
                    { case 2:
                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                      case 3:
                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size )
                            {   G( "in sector size 0: block_table_i=%x", block_table_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_1;
                            }
                            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                > disc->sata_ahci.physical_sector_size
                            )
                            {   G( "in sector not less than sector: block_table_i=%x", block_table_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_1;
                            }
                            disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                            continue_from = ~0;
                    }
        }
    }while( data != sector + disc->sata_ahci.physical_sector_size );
End_loop:
    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
    for_n( block_table_i_read, disc->partition[ partition_i ].oux.block_table_block_table_n ) // Czyta wszystkie pozostałe wpisy pliku tablicy bloków.
    {   if( block_table_i_read > block_table_i ) //NDFN Przemyśleć i zagwarantować, by zawsze starczało.
        {   G( "read beyond available: block_table_i=%x", block_table_i );
            r = ~0;
            goto End_1;
        }
        if( disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.pre )
            {   r = E_disc_I_read( disc_id, partition_i, disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].sector - 1, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End_1;
                Pc data = sector + ( disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.pre );
                do
                {   switch( continue_from )
                    { case ~0:
                            block_table_i++;
                            if( block_table_i == disc->partition[ partition_i ].oux.block_table_n )
                            {   G( "too much blocks size: block_table_i=%x", block_table_i );
                                r = ~0;
                                goto End_1;
                            }
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                      default:
                            if( continue_from == 1 )
                            {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                                if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_sectors
                                && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_in_sector
                                )
                                {   G( "location type unknown: block_table_i=%x", block_table_i );
                                    r = ~0;
                                    goto End_1;
                                }
                                disc->partition[ partition_i ].oux.block_table_size++;
                            }
                            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                                switch( continue_from )
                                { case 2:
                                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                                  case 3:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre >= disc->sata_ahci.physical_sector_size )
                                        {   G( "pre not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                  case 4:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post >= disc->sata_ahci.physical_sector_size )
                                        {   G( "post not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                        && ( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                            || !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                        ))
                                        {   G( "sectors and pre or post 0: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                        continue_from = ~0;
                                }
                            else
                                switch( continue_from )
                                { case 2:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                  case 3:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size )
                                        {   G( "in sector size 0: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                            + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                            > disc->sata_ahci.physical_sector_size
                                        )
                                        {   G( "in sector not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                        continue_from = ~0;
                                }
                    }
                }while( data != sector + disc->sata_ahci.physical_sector_size );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
            r = E_disc_I_read( disc_id, partition_i
            , disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].sector
            , disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.n
            , &sector, &r_
            );
            disc = E_mem_Q_tab_R( E_disc_S, disc_id );
            if(r)
                goto End_1;
            for_n( sector_i, disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.n ) // Czyta kolejne sektory z szeregu ciągłych.
            {   Pc data = sector;
                do
                {   switch( continue_from )
                    { case ~0:
                            block_table_i++;
                            if( block_table_i == disc->partition[ partition_i ].oux.block_table_n )
                            {   G( "too much blocks size: block_table_i=%x", block_table_i );
                                r = ~0;
                                goto End_1;
                            }
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                      default:
                            if( continue_from == 1 )
                            {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                                if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_sectors
                                && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_in_sector
                                )
                                {   G( "location type unknown: block_table_i=%x", block_table_i );
                                    r = ~0;
                                    goto End_1;
                                }
                                disc->partition[ partition_i ].oux.block_table_size++;
                            }
                            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                                switch( continue_from )
                                { case 2:
                                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                                  case 3:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre >= disc->sata_ahci.physical_sector_size )
                                        {   G( "pre not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                  case 4:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post >= disc->sata_ahci.physical_sector_size )
                                        {   G( "post not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                        && ( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                            || !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                        ))
                                        {   G( "sectors and pre or post 0: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                        continue_from = ~0;
                                }
                            else
                                switch( continue_from )
                                { case 2:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                  case 3:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                        , sector + disc->sata_ahci.physical_sector_size
                                        );
                                        if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size )
                                        {   G( "in sector size 0: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                            + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                            > disc->sata_ahci.physical_sector_size
                                        )
                                        {   G( "in sector not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                        continue_from = ~0;
                                }
                    }
                }while( data != sector + disc->sata_ahci.physical_sector_size );
                sector += disc->sata_ahci.physical_sector_size;
            }
            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            if( disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post )
            {   r = E_disc_I_read( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.n
                , 1, &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End_1;
                Pc data = sector;
                do
                {   switch( continue_from )
                    { case ~0:
                            block_table_i++;
                            if( block_table_i == disc->partition[ partition_i ].oux.block_table_n )
                            {   G( "too much blocks size: block_table_i=%x", block_table_i );
                                r = ~0;
                                goto End_1;
                            }
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                            , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post
                            );
                            disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                      default:
                            if( continue_from == 1 )
                            {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                                , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post
                                );
                                if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_sectors
                                && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_in_sector
                                )
                                {   G( "location type unknown: block_table_i=%x", block_table_i );
                                    r = ~0;
                                    goto End_1;
                                }
                                disc->partition[ partition_i ].oux.block_table_size++;
                            }
                            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                                switch( continue_from )
                                { case 2:
                                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                        , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post
                                        );
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                                  case 3:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                        , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post
                                        );
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre >= disc->sata_ahci.physical_sector_size )
                                        {   G( "pre not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                  case 4:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                        , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post
                                        );
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post >= disc->sata_ahci.physical_sector_size )
                                        {   G( "post not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                        && ( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                            || !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                        ))
                                        {   G( "sectors and pre or post 0: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                        continue_from = ~0;
                                }
                            else
                                switch( continue_from )
                                { case 2:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                        , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post
                                        );
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                  case 3:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                        , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post
                                        );
                                        if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size )
                                        {   G( "in sector size 0: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                            + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                            > disc->sata_ahci.physical_sector_size
                                        )
                                        {   G( "in sector not less than sector: block_table_i=%x", block_table_i );
                                            r = ~0;
                                            goto End_1;
                                        }
                                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                        continue_from = ~0;
                                }
                    }
                }while( data != sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.sectors.post );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
        }else
        {   r = E_disc_I_read( disc_id, partition_i, disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].sector, 1, &sector, &r_ );
            disc = E_mem_Q_tab_R( E_disc_S, disc_id );
            if(r)
                goto End_1;
            Pc data = sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start;
            do // Czyta wpisy pliku tablicy bloków znajdujące się we fragmencie sektora.
            {   switch( continue_from )
                { case ~0:
                        block_table_i++;
                        if( block_table_i == disc->partition[ partition_i ].oux.block_table_n )
                        {   G( "too much blocks size: block_table_i=%x", block_table_i );
                            r = ~0;
                            goto End_1;
                        }
                        continue_from++;
                  case 0:
                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        , sector
                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.size
                        );
                        disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                  default:
                        if( continue_from == 1 )
                        {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                            , sector
                              + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.size
                            );
                            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_sectors
                            && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type != E_ouxfs_Z_block_Z_location_S_in_sector
                            )
                            {   G( "location type unknown: block_table_i=%x", block_table_i );
                                r = ~0;
                                goto End_1;
                            }
                            disc->partition[ partition_i ].oux.block_table_size++;
                        }
                        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                            switch( continue_from )
                            { case 2:
                                    E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                    , sector
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.size
                                    );
                                    disc->partition[ partition_i ].oux.block_table_size += sizeof( N64 );
                              case 3:
                                    E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                    , sector
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.size
                                    );
                                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre >= disc->sata_ahci.physical_sector_size )
                                    {   G( "pre not less than sector: block_table_i=%x", block_table_i );
                                        r = ~0;
                                        goto End_1;
                                    }
                                    disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                              case 4:
                                    E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                    , sector
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.size
                                    );
                                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post >= disc->sata_ahci.physical_sector_size )
                                    {   G( "post not less than sector: block_table_i=%x", block_table_i );
                                        r = ~0;
                                        goto End_1;
                                    }
                                    if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                    && ( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                        || !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                    ))
                                    {   G( "sectors and pre or post 0: block_table_i=%x", block_table_i );
                                        r = ~0;
                                        goto End_1;
                                    }
                                    disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                    continue_from = ~0;
                            }
                        else
                            switch( continue_from )
                            { case 2:
                                    E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                    , sector
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.size
                                    );
                                    disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                              case 3:
                                    E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                    , sector
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start
                                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.size
                                    );
                                    if( !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size )
                                    {   G( "in sector size 0: block_table_i=%x", block_table_i );
                                        r = ~0;
                                        goto End_1;
                                    }
                                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                        + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                        > disc->sata_ahci.physical_sector_size
                                    )
                                    {   G( "in sector not less than sector: block_table_i=%x", block_table_i );
                                        r = ~0;
                                        goto End_1;
                                    }
                                    disc->partition[ partition_i ].oux.block_table_size += sizeof( N16 );
                                    continue_from = ~0;
                            }
                }
            }while( data != sector
              + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.start
              + disc->partition[ partition_i ].oux.block_table[ block_table_i_read ].location.in_sector.size
            );
            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
        }
    }
    if( ~continue_from )
    {   G( "too few blocks size" );
        r = ~0;
        goto End_1;
    }
    /*for_n_( block_table_i, disc->partition[ partition_i ].oux.block_table_n )
    {   G( "block_table_i: %x, sector: %x", block_table_i, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector );
        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post );
        else
            G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
    }*/
    // Utworzenie tablicy wolnych bloków.
    Mt_( disc->partition[ partition_i ].oux.free_table, 1 );
    if( !disc->partition[ partition_i ].oux.free_table )
    {   r = ~0;
        goto End_1;
    }
    disc->partition[ partition_i ].oux.free_table[0].sector = 1;
    disc->partition[ partition_i ].oux.free_table[0].location_type = E_ouxfs_Z_block_Z_location_S_sectors;
    disc->partition[ partition_i ].oux.free_table[0].location.sectors.n = disc->partition[ partition_i ].count - 1;
    disc->partition[ partition_i ].oux.free_table[0].location.sectors.pre = 0;
    disc->partition[ partition_i ].oux.free_table[0].location.sectors.post = 0;
    disc->partition[ partition_i ].oux.free_table_n = 1;
    for_n_( block_table_i, disc->partition[ partition_i ].oux.block_table_n )
    {   /*for_n( i, disc->partition[ partition_i ].oux.free_table_n )
        {   G( "%x. sector: %x", i, disc->partition[ partition_i ].oux.free_table[i].sector );
            if( disc->partition[ partition_i ].oux.free_table[i].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.free_table[i].location.sectors.n, disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre, disc->partition[ partition_i ].oux.free_table[i].location.sectors.post );
            else
                G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start, disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size );
        }
        G( "block %x. sector: %x", block_table_i, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector );
        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post );
        else
            G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );*/
        if( !disc->partition[ partition_i ].oux.free_table_n )
        {   G( "(1) no free block for allocated: block_table_i=%x", block_table_i );
            r = ~0;
            goto End_2;
        }
        N64 i = E_ouxfs_Q_free_table_R( disc_id, partition_i, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector );
        if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if( i == disc->partition[ partition_i ].oux.free_table_n
            || disc->partition[ partition_i ].oux.free_table[i].sector > disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
            )
                i--;
            else
            {   while( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                && ~--i
                ){} // Mogą być wpisy we fragmentach sektora powyżej, jeśli dla wyszukanego wpisu jest “!disc->partition[ partition_i ].oux.free_table[i].location.sectors.n”.
                if( !~i
                || disc->partition[ partition_i ].oux.free_table[i].location_type != E_ouxfs_Z_block_Z_location_S_sectors
                || disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                  < disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                || ( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                  == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                  && disc->partition[ partition_i ].oux.free_table[i].location.sectors.post < disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                ))
                    i++;
            }
            if( !~i
            || disc->partition[ partition_i ].oux.free_table[i].location_type != E_ouxfs_Z_block_Z_location_S_sectors
            || disc->partition[ partition_i ].oux.free_table[i].sector > disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
            || disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
              < disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
            )
            {   G( "(2) no free block for allocated: block_table_i=%x", block_table_i );
                r = ~0;
                goto End_2;
            }
            if(( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
              || ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                && disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
              ))
            && ( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
              != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
              || ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                && disc->partition[ partition_i ].oux.free_table[i].location.sectors.post != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
            ))) // Początkowe sektory (ewentualnie fragment poprzedniego (“pre”) sektora) z ostatnimi sektorami centralnych sektorów (ewentualnie fragmentem ostatniego (“post”) sektora) pozostają.
            {   if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                && disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre < disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                )
                {   G( "free pre less than allocated: block_table_i=%x", block_table_i );
                    r = ~0;
                    goto End_2;
                }
                if( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                  == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                && disc->partition[ partition_i ].oux.free_table[i].location.sectors.post < disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                )
                {   G( "free post less than allocated: block_table_i=%x", block_table_i );
                    r = ~0;
                    goto End_2;
                }
                if( !E_mem_Q_blk_I_insert( &disc->partition[ partition_i ].oux.free_table, i + 1, 1 ))
                {   r = ~0;
                    goto End_2;
                }
                disc->partition[ partition_i ].oux.free_table_n++;
                N64 free_sector = disc->partition[ partition_i ].oux.free_table[i].sector;
                N64 free_sectors_n = disc->partition[ partition_i ].oux.free_table[i].location.sectors.n;
                N64 free_pre = disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre;
                N64 free_post = disc->partition[ partition_i ].oux.free_table[i].location.sectors.post;
                if( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector )
                {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector -  disc->partition[ partition_i ].oux.free_table[i].sector;
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre )
                    {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n--;
                        disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                        if( !disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                        && !disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        )
                        {   N64 post = disc->partition[ partition_i ].oux.free_table[i].location.sectors.post;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = 0;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = post;
                        }
                    }else
                        disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = 0;
                }else
                {   disc->partition[ partition_i ].oux.free_table[i].sector--;
                    disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                    disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->sata_ahci.physical_sector_size - free_pre;
                    disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_pre - disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                }
                disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n;
                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.n =
                  free_sector + free_sectors_n
                  - disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector;
                if( free_sector + free_sectors_n
                  != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                )
                {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.n--;
                    if( disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.n
                    || free_post
                    )
                    {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector++;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.pre = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.post = free_post;
                    }else
                    {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start;
                    }
                }else if( free_sector + free_sectors_n
                  != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                )
                {   if( disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.n )
                    {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.pre = 0;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.post = free_post;
                    }else
                    {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                        disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                    }
                }else
                {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                    disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                    disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = free_post - disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start;
                }
            }else if(( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
              || ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                && disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
              ))
            && disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
              == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
            && disc->partition[ partition_i ].oux.free_table[i].location.sectors.post == disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
            ) // Początkowe sektory oraz ewentualnie fragment poprzedniego (“pre”) sektora pozostają.
            {   N64 free_pre = disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre;
                if( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector )
                {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector -  disc->partition[ partition_i ].oux.free_table[i].sector;
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre )
                    {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n--;
                        disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                        if( !disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                        && !disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        )
                        {   N64 post = disc->partition[ partition_i ].oux.free_table[i].location.sectors.post;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = 0;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = post;
                        }
                    }else
                        disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = 0;
                }else
                {   disc->partition[ partition_i ].oux.free_table[i].sector--;
                    disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                    disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->sata_ahci.physical_sector_size - free_pre;
                    disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_pre - disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre;
                }
            }else if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
            && disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre == disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
            && ( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
              != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
              || disc->partition[ partition_i ].oux.free_table[i].location.sectors.post != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
            )) // Ostatnie sektory centralnych sektorów z ewentualnym fragmentem ostatniego (“post”) sektora pozostają.
            {   N64 free_sector = disc->partition[ partition_i ].oux.free_table[i].sector;
                N64 free_sectors_n = disc->partition[ partition_i ].oux.free_table[i].location.sectors.n;
                N64 free_post = disc->partition[ partition_i ].oux.free_table[i].location.sectors.post;
                disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n;
                disc->partition[ partition_i ].oux.free_table[i].location.sectors.n =
                  free_sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                  - disc->partition[ partition_i ].oux.free_table[i].sector;
                if( free_sector + free_sectors_n
                  != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                )
                {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n--;
                    if( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                    || disc->partition[ partition_i ].oux.free_table[i].location.sectors.post
                    )
                    {   disc->partition[ partition_i ].oux.free_table[i].sector++;
                        disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                    }else
                    {   disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                        disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                        disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                    }
                }else if( free_sector + free_sectors_n
                  != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                )
                {   if( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n )
                        disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre = 0;
                    else
                    {   disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                        disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                        disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                    }
                }else
                {   disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                    disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post;
                    disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_post - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                }
            }else
            {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.free_table, i, 1 ))
                {   r = ~0;
                    goto End_2;
                }
                disc->partition[ partition_i ].oux.free_table_n--;
            }
        }else
        {   while( ~--i
            && disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
            ){} // Przesuwanie na początkową pozycję do wyszukiwania wolnego bloku zawierającego blok pliku.
            if( ~i
            && disc->partition[ partition_i ].oux.free_table[i].location_type == E_ouxfs_Z_block_Z_location_S_sectors
            )
            {   if( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n > disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                || ( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                  && disc->partition[ partition_i ].oux.free_table[i].location.sectors.post >= disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                ))
                {   // Znaleziony wolny blok typu “sectors” o wcześniejszym ‘sektorze’ początkowym zawierający wycinany blok.
                    if(( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                      || disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                    )
                    && ( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                      || disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                      || disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                    )
                    && ( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                      || disc->partition[ partition_i ].oux.free_table[i].location.sectors.post != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                    )
                    && ( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                      || disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                      || disc->partition[ partition_i ].oux.free_table[i].location.sectors.post
                    )) // Początkowy oraz końcowy fragment pozostają.
                    {   if( !E_mem_Q_blk_I_insert( &disc->partition[ partition_i ].oux.free_table, i + 1, 1 ))
                        {   r = ~0;
                            goto End_2;
                        }
                        disc->partition[ partition_i ].oux.free_table_n++;
                        N64 free_sector = disc->partition[ partition_i ].oux.free_table[i].sector;
                        N64 free_sectors_n = disc->partition[ partition_i ].oux.free_table[i].location.sectors.n;
                        N64 free_pre = disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre;
                        N64 free_post = disc->partition[ partition_i ].oux.free_table[i].location.sectors.post;
                        if( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 )
                        {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector - disc->partition[ partition_i ].oux.free_table[i].sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start;
                        }else
                        {   disc->partition[ partition_i ].oux.free_table[i].sector--;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->sata_ahci.physical_sector_size - free_pre;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->sata_ahci.physical_sector_size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start );
                        }
                        if( free_sector + free_sectors_n > disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 )
                        {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.pre = disc->sata_ahci.physical_sector_size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.n = free_sector + free_sectors_n - disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.post = free_post;
                        }else if( free_sector + free_sectors_n == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 )
                        {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                            && free_post
                            )
                            {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.pre = disc->sata_ahci.physical_sector_size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.n = free_sector + free_sectors_n - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 );
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.post = free_post;
                            }else if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                            && !free_post
                            )
                            {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start;
                            }else
                            {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = 0;
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = free_post;
                            }
                        }else
                        {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = free_post - disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start;
                        }
                    }else if(( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                      || !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                    )
                    && ( disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                      || disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre == disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                    )
                    && ( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                      || disc->partition[ partition_i ].oux.free_table[i].location.sectors.post != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                    )
                    && ( disc->partition[ partition_i ].oux.free_table[i].sector + disc->partition[ partition_i ].oux.free_table[i].location.sectors.n != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                      || disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                      || disc->partition[ partition_i ].oux.free_table[i].location.sectors.post
                    )) // Końcowy fragment pozostaje.
                    {   N64 free_sector = disc->partition[ partition_i ].oux.free_table[i].sector;
                        N64 free_sectors_n = disc->partition[ partition_i ].oux.free_table[i].location.sectors.n;
                        N64 free_post = disc->partition[ partition_i ].oux.free_table[i].location.sectors.post;
                        if( free_sector + free_sectors_n > disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 )
                        {   disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                            disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre = disc->sata_ahci.physical_sector_size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
                            disc->partition[ partition_i ].oux.free_table[i].location.sectors.n = free_sector + free_sectors_n - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 );
                            disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = free_post;
                        }else if( free_sector + free_sectors_n == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 )
                        {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                            && free_post
                            )
                            {   disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                                disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                                disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre = disc->sata_ahci.physical_sector_size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
                                disc->partition[ partition_i ].oux.free_table[i].location.sectors.n = free_sector + free_sectors_n - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 );
                                disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = free_post;
                            }else if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                            && !free_post
                            )
                            {   disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                                disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                                disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                            }else
                            {   disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                                disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = 0;
                                disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_post;
                            }
                        }else
                        {   disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_post - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                        }
                    }else // Początkowy fragment pozostaje.
                    {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector - disc->partition[ partition_i ].oux.free_table[i].sector;
                        disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start;
                    }
                    continue;
                }
            }
            i++;
            if( i == disc->partition[ partition_i ].oux.free_table_n )
            {   G( "(3) no free block for allocated: block_table_i=%x", block_table_i );
                r = ~0;
                goto End_2;
            }
Next_sector:if( disc->partition[ partition_i ].oux.free_table[i].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            {   if( disc->partition[ partition_i ].oux.free_table[i].sector > disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                || ( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                  && disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre > disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                ))
                {   G( "(4) no free block for allocated: block_table_i=%x", block_table_i );
                    r = ~0;
                    goto End_2;
                }
                if(( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                  && ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                    || disc->partition[ partition_i ].oux.free_table[i].location.sectors.post >= disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                ))
                || disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                ) // Znaleziony wolny blok typu “sectors” o tym samym lub następnym ‘sektorze’ początkowym zawierający wycinany blok.
                {   if(( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                      && ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        || disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                      )
                      && ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n > 1
                        || ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n == 1
                          && ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.post
                            || disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                        ))
                        || ( !disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                          && disc->partition[ partition_i ].oux.free_table[i].location.sectors.post != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                    )))
                    || ( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                      && disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                    )) // Początkowy oraz końcowy fragment pozostają.
                    {   if( !E_mem_Q_blk_I_insert( &disc->partition[ partition_i ].oux.free_table, i + 1, 1 ))
                        {   r = ~0;
                            goto End_2;
                        }
                        disc->partition[ partition_i ].oux.free_table_n++;
                        N64 free_sector = disc->partition[ partition_i ].oux.free_table[i].sector;
                        N64 free_sectors_n = disc->partition[ partition_i ].oux.free_table[i].location.sectors.n;
                        N64 free_pre = disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre;
                        N64 free_post = disc->partition[ partition_i ].oux.free_table[i].location.sectors.post;
                        if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        && disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                        )
                        {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n = 0;
                            disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start;
                        }else if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        && disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        && !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                        )
                        {   disc->partition[ partition_i ].oux.free_table[i].sector--;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->sata_ahci.physical_sector_size - free_pre;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_pre;
                        }else if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        && !disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                        )
                        {   disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = 0;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start;
                        }else
                        {   disc->partition[ partition_i ].oux.free_table[i].sector--;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->sata_ahci.physical_sector_size - free_pre;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                        }
                        if(( free_sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                          && ( free_sectors_n > 1
                            || ( free_sectors_n == 1
                              && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                        )))
                        || ( free_sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                          && ( free_sectors_n
                            || ( free_post
                              && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                        ))))
                        {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_sectors;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.n = free_sectors_n;
                            if( free_sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector )
                                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.n--;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.pre = disc->sata_ahci.physical_sector_size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.sectors.post = free_post;
                        }else if(( free_sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                          && free_sectors_n == 1
                        )
                        || ( free_sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                          && free_post
                        ))
                        {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = 0;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = free_post;
                        }else if( free_sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector )
                        {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = free_post - disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start;
                        }else
                        {   disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start;
                        }
                    }else if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                    && ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                      || disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                    )
                    && (( !disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                        && disc->partition[ partition_i ].oux.free_table[i].location.sectors.post == disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                      )
                      || ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n == 1
                        && !disc->partition[ partition_i ].oux.free_table[i].location.sectors.post
                        && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size == disc->sata_ahci.physical_sector_size
                    ))) // Początkowy fragment pozostaje.
                    {   N64 free_pre = disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre;
                        if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        && disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                        )
                        {   disc->partition[ partition_i ].oux.free_table[i].location.sectors.n = 0;
                            disc->partition[ partition_i ].oux.free_table[i].location.sectors.post = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start;
                        }else if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        && disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        && !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                        )
                        {   disc->partition[ partition_i ].oux.free_table[i].sector--;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->sata_ahci.physical_sector_size - free_pre;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_pre;
                        }else if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                        && !disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                        && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                        )
                        {   disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = 0;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start;
                        }else if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 )
                        {   disc->partition[ partition_i ].oux.free_table[i].sector--;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->sata_ahci.physical_sector_size - free_pre;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                        }
                    }else if(( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                      && !disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                      && !disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre
                      && ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                        || disc->partition[ partition_i ].oux.free_table[i].location.sectors.post != disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                    ))
                    || ( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                      && disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre == disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                    )) // Końcowy fragment pozostaje.
                    {   N64 free_sector = disc->partition[ partition_i ].oux.free_table[i].sector;
                        N64 free_post = disc->partition[ partition_i ].oux.free_table[i].location.sectors.post;
                        if(( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                          && ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n > 1
                            || ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n == 1
                              && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                        )))
                        || ( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                          && ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.n
                            || ( disc->partition[ partition_i ].oux.free_table[i].location.sectors.post
                              && disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size != disc->sata_ahci.physical_sector_size
                        ))))
                        {   disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                            if( free_sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector )
                                disc->partition[ partition_i ].oux.free_table[i].location.sectors.n--;
                            disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre = disc->sata_ahci.physical_sector_size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
                        }else if(( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                          && disc->partition[ partition_i ].oux.free_table[i].location.sectors.n == 1
                        )
                        || ( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1
                          && disc->partition[ partition_i ].oux.free_table[i].location.sectors.post
                        ))
                        {   disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = 0;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_post;
                        }else if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector )
                        {   disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_post - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                        }else
                        {   disc->partition[ partition_i ].oux.free_table[i].sector = disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector;
                            disc->partition[ partition_i ].oux.free_table[i].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                            disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                        }
                    }else // Cały wolny blok znika.
                    {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.free_table, i, 1 ))
                        {   r = ~0;
                            goto End_2;
                        }
                        disc->partition[ partition_i ].oux.free_table_n--;
                    }
                    continue;
                }
                i++;
                if( i == disc->partition[ partition_i ].oux.free_table_n
                || disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                )
                {   if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 )
                        goto Next_sector;
                    G( "(5) no free block for allocated: block_table_i=%x", block_table_i );
                    r = ~0;
                    goto End_2;
                }
            }
            while( disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start + disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size
              < disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
            ) // Wyszukiwanie kandydata typu “in_sector” w tablicy wolnych bloków.
            {   i++;
                if( i == disc->partition[ partition_i ].oux.free_table_n
                || disc->partition[ partition_i ].oux.free_table[i].sector != disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                )
                {   if( disc->partition[ partition_i ].oux.free_table[i].sector == disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector + 1 )
                        goto Next_sector;
                    G( "(6) no free block for allocated: block_table_i=%x", block_table_i );
                    r = ~0;
                    goto End_2;
                }
            }
            if( disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start > disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start )
            {   G( "(7) no free block for allocated: block_table_i=%x", block_table_i );
                r = ~0;
                goto End_2;
            }
            // Znaleziony wolny blok typu “in_sector” zawierający wycinany blok.
            if( disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start < disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
            && disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start + disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size
              > disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
            ) // Początkowy oraz końcowy fragment pozostają.
            {   if( !E_mem_Q_blk_I_insert( &disc->partition[ partition_i ].oux.free_table, i + 1, 1 ))
                {   r = ~0;
                    goto End_2;
                }
                disc->partition[ partition_i ].oux.free_table_n++;
                N64 free_size = disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size;
                disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                disc->partition[ partition_i ].oux.free_table[ i + 1 ].sector = disc->partition[ partition_i ].oux.free_table[i].sector;
                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                disc->partition[ partition_i ].oux.free_table[ i + 1 ].location.in_sector.size = disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start + free_size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
            }else if( disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start < disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
            && disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start + disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size
              == disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
            ) // Początkowy fragment pozostaje.
                disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start - disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
            else if( disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start == disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
            && disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start + disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size
              > disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
            ) // Końcowy fragment pozostaje
            {   N64 free_start = disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start;
                disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start = disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size;
                disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size = free_start + disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size - ( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
            }else // Cały wolny blok znika.
            {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.free_table, i, 1 ))
                {   r = ~0;
                    goto End_2;
                }
                disc->partition[ partition_i ].oux.free_table_n--;
            }
        }
        for_n( j, disc->partition[ partition_i ].oux.free_table_n )
        {   if( j == i )
                continue;
            if( E_ouxfs_Q_block_T_cross( disc_id, partition_i
            , &disc->partition[ partition_i ].oux.free_table[i]
            , &disc->partition[ partition_i ].oux.free_table[j]
            )) // Sprawdzenie na czas testów.
            {   G( "cross: i=%x, j=%x", i, j );
                /*for_n( i, disc->partition[ partition_i ].oux.free_table_n )
                {   G( "%x. sector: %x", i, disc->partition[ partition_i ].oux.free_table[i].sector );
                    if( disc->partition[ partition_i ].oux.free_table[i].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                        G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.free_table[i].location.sectors.n, disc->partition[ partition_i ].oux.free_table[i].location.sectors.pre, disc->partition[ partition_i ].oux.free_table[i].location.sectors.post );
                    else
                        G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.free_table[i].location.in_sector.start, disc->partition[ partition_i ].oux.free_table[i].location.in_sector.size );
                }*/
                goto End_2;
            }
        }
    }
    // Odczyt tablicy katalogów do pamięci operacyjnej.
    Mt_( disc->partition[ partition_i ].oux.directory, 0 );
    if( !disc->partition[ partition_i ].oux.directory )
    {   r = ~0;
        goto End_2;
    }
    disc->partition[ partition_i ].oux.directory_n = 0;
    N64 directory_i = 0;
    N64 uid_last = ~0;
    data_i = 0;
    N char_i, char_n;
    for_n( directory_table_i, disc->partition[ partition_i ].oux.block_table_directory_table_n )
    {   /*G( "directory_table_start: %x, directory_table_i: %x", disc->partition[ partition_i ].oux.block_table_directory_table_start, directory_table_i );
        G( "sector: %x", disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector );
        if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.n, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.pre, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post );
        else
            G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size );*/
        if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.pre )
            {   r = E_disc_I_read( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector - 1
                , 1, &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End_3;
                Pc data = sector + ( disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.pre );
                do
                {   switch( continue_from )
                    { case ~0:
                            if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.directory, 1 ))
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            directory_i = disc->partition[ partition_i ].oux.directory_n++;
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( !~disc->partition[ partition_i ].oux.directory[ directory_i ].uid )
                            {   G( "uid empty: directory_i=%x", directory_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            if( ~uid_last
                            && uid_last >= disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                            )
                            {   G( "uid not sorted or duplicate: directory_i=%x", directory_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            uid_last = disc->partition[ partition_i ].oux.directory[ directory_i ].uid;
                      case 1:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].parent
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            char_n = sector + disc->sata_ahci.physical_sector_size - data;
                            P p = M( char_n );
                            if( !p )
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            disc->partition[ partition_i ].oux.directory[ directory_i ].name = p;
                            char_i = 0;
                      case 2:
                            while( data != sector + disc->sata_ahci.physical_sector_size )
                            {   disc->partition[ partition_i ].oux.directory[ directory_i ].name[ char_i++ ] = *data;
                                if( !*data )
                                {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, char_i, char_n - char_i ))
                                    {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                        W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
                                        r = ~0;
                                        goto End_3;
                                    }
                                    break;
                                }
                                data++;
                            }
                            if( data == sector + disc->sata_ahci.physical_sector_size )
                            {   if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, disc->sata_ahci.physical_sector_size ))
                                {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
                                    r = ~0;
                                    goto End_3;
                                }
                                char_n += disc->sata_ahci.physical_sector_size;
                            }else
                            {   data++;
                                continue_from = ~0;
                            }
                    }
                }while( data != sector + disc->sata_ahci.physical_sector_size );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
            r = E_disc_I_read( disc_id, partition_i
            , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector
            , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.n
            , &sector, &r_
            );
            disc = E_mem_Q_tab_R( E_disc_S, disc_id );
            if(r)
                goto End_3;
            for_n( sector_i, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.n )
            {   Pc data = sector;
                do
                {   switch( continue_from )
                    { case ~0:
                            if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.directory, 1 ))
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            directory_i = disc->partition[ partition_i ].oux.directory_n++;
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( !~disc->partition[ partition_i ].oux.directory[ directory_i ].uid )
                            {   G( "uid empty: directory_i=%x", directory_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            if( ~uid_last
                            && uid_last >= disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                            )
                            {   G( "uid not sorted or duplicate: directory_i=%x", directory_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );r = ~0;
                                goto End_3;
                            }
                            uid_last = disc->partition[ partition_i ].oux.directory[ directory_i ].uid;
                      case 1:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].parent
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            char_n = sector + disc->sata_ahci.physical_sector_size - data;
                            P p = M( char_n );
                            if( !p )
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            disc->partition[ partition_i ].oux.directory[ directory_i ].name = p;
                            char_i = 0;
                      case 2:
                            while( data != sector + disc->sata_ahci.physical_sector_size )
                            {   disc->partition[ partition_i ].oux.directory[ directory_i ].name[ char_i++ ] = *data;
                                if( !*data )
                                {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, char_i, char_n - char_i ))
                                    {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                        W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
                                        r = ~0;
                                        goto End_3;
                                    }
                                    break;
                                }
                                data++;
                            }
                            if( data == sector + disc->sata_ahci.physical_sector_size )
                            {   if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, disc->sata_ahci.physical_sector_size ))
                                {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
                                    r = ~0;
                                    goto End_3;
                                }
                                char_n += disc->sata_ahci.physical_sector_size;
                            }else
                            {   data++;
                                continue_from = ~0;
                            }
                    }
                }while( data != sector + disc->sata_ahci.physical_sector_size );
                sector += disc->sata_ahci.physical_sector_size;
            }
            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post )
            {   r = E_disc_I_read( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector
                  + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.n
                , 1, &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End_3;
                Pc data = sector;
                do
                {   switch( continue_from )
                    { case ~0:
                            if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.directory, 1 ))
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            directory_i = disc->partition[ partition_i ].oux.directory_n++;
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                            , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post
                            );
                            if( !~disc->partition[ partition_i ].oux.directory[ directory_i ].uid )
                            {   G( "uid empty: directory_i=%x", directory_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            if( ~uid_last
                            && uid_last >= disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                            )
                            {   G( "uid not sorted or duplicate: directory_i=%x", directory_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            uid_last = disc->partition[ partition_i ].oux.directory[ directory_i ].uid;
                      case 1:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].parent
                            , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post
                            );
                            char_n = sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post - data;
                            P p = M( char_n );
                            if( !p )
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_3;
                            }
                            disc->partition[ partition_i ].oux.directory[ directory_i ].name = p;
                            char_i = 0;
                      case 2:
                            while( data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post )
                            {   disc->partition[ partition_i ].oux.directory[ directory_i ].name[ char_i++ ] = *data;
                                if( !*data )
                                {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, char_i, char_n - char_i ))
                                    {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                        W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
                                        r = ~0;
                                        goto End_3;
                                    }
                                    break;
                                }
                                data++;
                            }
                            if( data == sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post )
                            {   if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, disc->sata_ahci.physical_sector_size ))
                                {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
                                    r = ~0;
                                    goto End_3;
                                }
                                char_n += disc->sata_ahci.physical_sector_size;
                            }else
                            {   data++;
                                continue_from = ~0;
                            }
                    }
                }while( data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
        }else
        {   r = E_disc_I_read( disc_id, partition_i
            , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector
            , 1, &sector, &r_
            );
            disc = E_mem_Q_tab_R( E_disc_S, disc_id );
            if(r)
                goto End_3;
            Pc data = sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start;
            do
            {   switch( continue_from )
                { case ~0:
                        if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.directory, 1 ))
                        {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                            r = ~0;
                            goto End_3;
                        }
                        directory_i = disc->partition[ partition_i ].oux.directory_n++;
                        continue_from++;
                  case 0:
                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                        , sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                        );
                        if( !~disc->partition[ partition_i ].oux.directory[ directory_i ].uid )
                        {   G( "uid empty: directory_i=%x", directory_i );
                            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );r = ~0;
                            goto End_3;
                        }
                        if( ~uid_last
                        && uid_last >= disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                        )
                        {   G( "uid not sorted or duplicate: directory_i=%x", directory_i );
                            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                            r = ~0;
                            goto End_3;
                        }
                        uid_last = disc->partition[ partition_i ].oux.directory[ directory_i ].uid;
                  case 1:
                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].parent
                        , sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                        );
                        char_n = sector
                        + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                        + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                        - data;
                        P p = M( char_n );
                        if( !p )
                        {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                            r = ~0;
                            goto End_3;
                        }
                        disc->partition[ partition_i ].oux.directory[ directory_i ].name = p;
                        char_i = 0;
                  case 2:
                        while( data != sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                        )
                        {   disc->partition[ partition_i ].oux.directory[ directory_i ].name[ char_i++ ] = *data;
                            if( !*data )
                            {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, char_i, char_n - char_i ))
                                {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
                                    r = ~0;
                                    goto End_3;
                                }
                                break;
                            }
                            data++;
                        }
                        if( data == sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                        )
                        {   if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, disc->sata_ahci.physical_sector_size ))
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
                                r = ~0;
                                goto End_3;
                            }
                            char_n += disc->sata_ahci.physical_sector_size;
                        }else
                        {   data++;
                            continue_from = ~0;
                        }
                }
            }while( data != sector
              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
            );
            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
        }
    }
    if( ~continue_from )
    {   G( "too few blocks size" );
        r = ~0;
        goto End_3;
    }
    /*G( "directories:" );
    for_n_( directory_i, disc->partition[ partition_i ].oux.directory_n )
        G( "%x. uid: %x, parent: %x, name: %s", directory_i, disc->partition[ partition_i ].oux.directory[ directory_i ].uid, disc->partition[ partition_i ].oux.directory[ directory_i ].parent, disc->partition[ partition_i ].oux.directory[ directory_i ].name );*/
    // Odczyt tablicy plików do pamięci operacyjnej.
    Mt_( disc->partition[ partition_i ].oux.file, 0 );
    if( !disc->partition[ partition_i ].oux.file )
    {   r = ~0;
        goto End_3;
    }
    disc->partition[ partition_i ].oux.file_n = 0;
    N64 file_i = 0;
    uid_last = ~0;
    data_i = 0;
    for_n( file_table_i, disc->partition[ partition_i ].oux.block_table_file_table_n )
    {   /*G( "file_table_start: %x, file_table_i: %x", disc->partition[ partition_i ].oux.block_table_file_table_start, file_table_i );
        G( "sector: %x", disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector );
        if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.n, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.pre, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post );
        else
            G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size );*/
        if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.pre )
            {   r = E_disc_I_read( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector - 1
                , 1, &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End_4;
                Pc data = sector + ( disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.pre );
                do
                {   switch( continue_from )
                    { case ~0:
                            if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.file, 1 ))
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            file_i = disc->partition[ partition_i ].oux.file_n++;
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].uid
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( !~disc->partition[ partition_i ].oux.file[ file_i ].uid )
                            {   G( "uid empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            if( ~uid_last
                            && uid_last >= disc->partition[ partition_i ].oux.file[ file_i ].uid
                            )
                            {   G( "uid not sorted or duplicate: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            uid_last = disc->partition[ partition_i ].oux.file[ file_i ].uid;
                      case 1:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].parent
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                      case 2:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                      case 3:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            && !~disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            )
                            {   G( "block start empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            if( !~disc->partition[ partition_i ].oux.file[ file_i ].block_table.n )
                            {   G( "block count empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            char_n = sector + disc->sata_ahci.physical_sector_size - data;
                            P p = M( char_n );
                            if( !p )
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );r = ~0;
                                goto End_4;
                            }
                            disc->partition[ partition_i ].oux.file[ file_i ].name = p;
                            char_i = 0;
                      case 4:
                            while( data != sector + disc->sata_ahci.physical_sector_size )
                            {   disc->partition[ partition_i ].oux.file[ file_i ].name[ char_i++ ] = *data;
                                if( !*data )
                                {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.file[ file_i ].name, char_i, char_n - char_i ))
                                    {   W( disc->partition[ partition_i ].oux.file[ file_i ].name );
                                        E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                        r = ~0;
                                        goto End_4;
                                    }
                                    break;
                                }
                                data++;
                            }
                            if( data == sector + disc->sata_ahci.physical_sector_size )
                            {   if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.file[ file_i ].name, disc->sata_ahci.physical_sector_size ))
                                {   W( disc->partition[ partition_i ].oux.file[ file_i ].name );
                                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    r = ~0;
                                    goto End_4;
                                }
                                char_n += disc->sata_ahci.physical_sector_size;
                            }else
                            {   data++;
                                disc->partition[ partition_i ].oux.file[ file_i ].lock_write = no;
                                disc->partition[ partition_i ].oux.file[ file_i ].lock_read = no;
                                continue_from = ~0;
                            }
                    }
                }while( data != sector + disc->sata_ahci.physical_sector_size );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
            r = E_disc_I_read( disc_id, partition_i
            , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector
            , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.n
            , &sector, &r_
            );
            disc = E_mem_Q_tab_R( E_disc_S, disc_id );
            if(r)
                goto End_4;
            for_n( sector_i, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.n )
            {   Pc data = sector;
                do
                {   switch( continue_from )
                    { case ~0:
                            if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.file, 1 ))
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            file_i = disc->partition[ partition_i ].oux.file_n++;
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].uid
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( !~disc->partition[ partition_i ].oux.file[ file_i ].uid )
                            {   G( "uid empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            if( ~uid_last
                            && uid_last >= disc->partition[ partition_i ].oux.file[ file_i ].uid
                            )
                            {   G( "uid not sorted or duplicate: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            uid_last = disc->partition[ partition_i ].oux.file[ file_i ].uid;
                      case 1:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].parent
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                      case 2:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                      case 3:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            , sector + disc->sata_ahci.physical_sector_size
                            );
                            if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            && !~disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            )
                            {   G( "block start empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            if( !~disc->partition[ partition_i ].oux.file[ file_i ].block_table.n )
                            {   G( "block count empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            char_n = sector + disc->sata_ahci.physical_sector_size - data;
                            P p = M( char_n );
                            if( !p )
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            disc->partition[ partition_i ].oux.file[ file_i ].name = p;
                            char_i = 0;
                      case 4:
                            while( data != sector + disc->sata_ahci.physical_sector_size )
                            {   disc->partition[ partition_i ].oux.file[ file_i ].name[ char_i++ ] = *data;
                                if( !*data )
                                {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.file[ file_i ].name, char_i, char_n - char_i ))
                                    {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                        W( disc->partition[ partition_i ].oux.file[ file_i ].name );
                                        r = ~0;
                                        goto End_4;
                                    }
                                    break;
                                }
                                data++;
                            }
                            if( data == sector + disc->sata_ahci.physical_sector_size )
                            {   if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.file[ file_i ].name, disc->sata_ahci.physical_sector_size ))
                                {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    W( disc->partition[ partition_i ].oux.file[ file_i ].name );
                                    r = ~0;
                                    goto End_4;
                                }
                                char_n += disc->sata_ahci.physical_sector_size;
                            }else
                            {   data++;
                                disc->partition[ partition_i ].oux.file[ file_i ].lock_write = no;
                                disc->partition[ partition_i ].oux.file[ file_i ].lock_read = no;
                                continue_from = ~0;
                            }
                    }
                }while( data != sector + disc->sata_ahci.physical_sector_size );
                sector += disc->sata_ahci.physical_sector_size;
            }
            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post )
            {   r = E_disc_I_read( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector
                  + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.n
                , 1, &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End_4;
                Pc data = sector;
                do
                {   switch( continue_from )
                    { case ~0:
                            if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.file, 1 ))
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            file_i = disc->partition[ partition_i ].oux.file_n++;
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].uid
                            , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                            );
                            if( !~disc->partition[ partition_i ].oux.file[ file_i ].uid )
                            {   G( "uid empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            if( ~uid_last
                            && uid_last >= disc->partition[ partition_i ].oux.file[ file_i ].uid
                            )
                            {   G( "uid not sorted or duplicate: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            uid_last = disc->partition[ partition_i ].oux.file[ file_i ].uid;
                      case 1:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].parent
                            , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                            );
                      case 2:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                            );
                      case 3:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                            );
                            if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            && !~disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            )
                            {   G( "block start empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            if( !~disc->partition[ partition_i ].oux.file[ file_i ].block_table.n )
                            {   G( "block count empty: file_i=%x", file_i );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            char_n = sector
                            + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                            - data;
                            P p = M( char_n );
                            if( !p )
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                r = ~0;
                                goto End_4;
                            }
                            disc->partition[ partition_i ].oux.file[ file_i ].name = p;
                            char_i = 0;
                      case 4:
                            while( data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post )
                            {   disc->partition[ partition_i ].oux.file[ file_i ].name[ char_i++ ] = *data;
                                if( !*data )
                                {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.file[ file_i ].name, char_i, char_n - char_i ))
                                    {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                        W( disc->partition[ partition_i ].oux.file[ file_i ].name );
                                        r = ~0;
                                        goto End_4;
                                    }
                                    break;
                                }
                                data++;
                            }
                            if( data == sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post )
                            {   if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.file[ file_i ].name, disc->sata_ahci.physical_sector_size ))
                                {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    W( disc->partition[ partition_i ].oux.file[ file_i ].name );
                                    r = ~0;
                                    goto End_4;
                                }
                                char_n += disc->sata_ahci.physical_sector_size;
                            }else
                            {   data++;
                                disc->partition[ partition_i ].oux.file[ file_i ].lock_write = no;
                                disc->partition[ partition_i ].oux.file[ file_i ].lock_read = no;
                                continue_from = ~0;
                            }
                    }
                }while( data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
        }else
        {   r = E_disc_I_read( disc_id, partition_i
            , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector
            , 1, &sector, &r_
            );
            disc = E_mem_Q_tab_R( E_disc_S, disc_id );
            if(r)
                goto End_4;
            Pc data = sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start;
            do
            {   switch( continue_from )
                { case ~0:
                        if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.file, 1 ))
                        {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                            r = ~0;
                            goto End_4;
                        }
                        file_i = disc->partition[ partition_i ].oux.file_n++;
                        continue_from++;
                  case 0:
                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].uid
                        , sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                        );
                        if( !~disc->partition[ partition_i ].oux.file[ file_i ].uid )
                        {   G( "uid empty: file_i=%x", file_i );
                            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                            r = ~0;
                            goto End_4;
                        }
                        if( ~uid_last
                        && uid_last >= disc->partition[ partition_i ].oux.file[ file_i ].uid
                        )
                        {   G( "uid not sorted or duplicate: file_i=%x", file_i );
                            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                            r = ~0;
                            goto End_4;
                        }
                        uid_last = disc->partition[ partition_i ].oux.file[ file_i ].uid;
                  case 1:
                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].parent
                        , sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                        );
                  case 2:
                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                        , sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                        );
                  case 3:
                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                        , sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                        );
                        if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                        && !~disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                        )
                        {   G( "block start empty: file_i=%x", file_i );
                            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                            r = ~0;
                            goto End_4;
                        }
                        char_n = sector
                        + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                        + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size - data;
                        P p = M( char_n );
                        if( !p )
                        {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                            r = ~0;
                            goto End_4;
                        }
                        disc->partition[ partition_i ].oux.file[ file_i ].name = p;
                        char_i = 0;
                  case 4:
                        while( data != sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                        )
                        {   disc->partition[ partition_i ].oux.file[ file_i ].name[ char_i++ ] = *data;
                            if( !*data )
                            {   if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.file[ file_i ].name, char_i, char_n - char_i ))
                                {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    W( disc->partition[ partition_i ].oux.file[ file_i ].name );
                                    r = ~0;
                                    goto End_4;
                                }
                                break;
                            }
                            data++;
                        }
                        if( data == sector
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                        )
                        {   if( !E_mem_Q_blk_I_append( &disc->partition[ partition_i ].oux.file[ file_i ].name, disc->sata_ahci.physical_sector_size ))
                            {   E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                W( disc->partition[ partition_i ].oux.file[ file_i ].name );
                                r = ~0;
                                goto End_4;
                            }
                            char_n += disc->sata_ahci.physical_sector_size;
                        }else
                        {   data++;
                            disc->partition[ partition_i ].oux.file[ file_i ].lock_write = no;
                            disc->partition[ partition_i ].oux.file[ file_i ].lock_read = no;
                            continue_from = ~0;
                        }
                }
            }while( data != sector
              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
            );
            E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
        }
    }
    if( ~continue_from )
    {   G( "too few blocks size" );
        r = ~0;
        goto End_4;
    }
    /*G( "files:" );
    for_n_( file_i, disc->partition[ partition_i ].oux.file_n )
        G( "%x. uid: %x, parent: %x, name: %s, lock_write: %8x, lock_read: %8x", file_i, disc->partition[ partition_i ].oux.file[ file_i ].uid, disc->partition[ partition_i ].oux.file[ file_i ].parent, disc->partition[ partition_i ].oux.file[ file_i ].name, disc->partition[ partition_i ].oux.file[ file_i ].lock_write, disc->partition[ partition_i ].oux.file[ file_i ].lock_read );*/
    disc->partition[ partition_i ].oux.block_table_changed_from = ~0;
    disc->partition[ partition_i ].oux.file_table_changed_from = ~0;
    disc->partition[ partition_i ].oux.directory_table_changed_from = ~0;
    E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
End_4:
    for_n( file_i_, file_i )
        W( disc->partition[ partition_i ].oux.file[ file_i_ ].name );
    W( disc->partition[ partition_i ].oux.file );
End_3:
    for_n( directory_i_, directory_i )
        W( disc->partition[ partition_i ].oux.directory[ directory_i_ ].name );
    W( disc->partition[ partition_i ].oux.directory );
End_2:
    W( disc->partition[ partition_i ].oux.free_table );
End_1:
    W( disc->partition[ partition_i ].oux.block_table );
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//------------------------------------------------------------------------------
#undef E_ouxfs_Q_device_I_switch_item
#define E_ouxfs_Q_device_I_switch_item( type, item, end ) \
    if( data_i ) \
    {   do \
        {   *data++ = ( item >> data_i++ * 8 ) & 0xff; \
        }while( data_i != sizeof(type) \
        && data != (end) \
        ); \
        if( data_i == sizeof(type) ) \
            data_i = 0; \
        else \
            break; \
    }else \
    {   if( data == (end) ) \
            break; \
        if( data + sizeof(type) > (end) ) \
        {   do \
            {   *data++ = ( item >> data_i++ * 8 ) & 0xff; \
            }while( data != (end) ); \
            break; \
        } \
        *( type * )data = item; \
        data += sizeof(type); \
    } \
    continue_from++
//------------------------------------------------------------------------------
_internal
N
E_ouxfs_Q_device_I_save( I disc_id
, N partition_i
){  struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    Pc sector;
    N r = 0;
    if( ~disc->partition[ partition_i ].oux.block_table_changed_from )
    {   N r_;
        r = E_disc_I_write( disc_id, partition_i, 0, 1, &sector, &r_ );
        disc = E_mem_Q_tab_R( E_disc_S, disc_id );
        if(r)
            return r;
        _0( sector, disc->sata_ahci.physical_sector_size ); //NDFN Czy to potrzebne?
        E_text_Z_s_P_copy_s0_0( sector, E_ouxfs_Q_device_S_ident );
        sector[ sizeof( E_ouxfs_Q_device_S_ident ) ] = __builtin_ctz( disc->sata_ahci.physical_sector_size );
        N64 *block_table_n = E_simple_Z_p_I_align_up_to_v2( sector + sizeof( E_ouxfs_Q_device_S_ident ) + 1, sizeof( N64 ));
        block_table_n[0] = disc->partition[ partition_i ].oux.block_table_n;
        block_table_n[1] = disc->partition[ partition_i ].oux.block_table_block_table_n;
        block_table_n[2] = disc->partition[ partition_i ].oux.block_table_directory_table_start;
        block_table_n[3] = disc->partition[ partition_i ].oux.block_table_directory_table_n;
        block_table_n[4] = disc->partition[ partition_i ].oux.block_table_file_table_start;
        block_table_n[5] = disc->partition[ partition_i ].oux.block_table_file_table_n;
        Pc data = ( void * )&block_table_n[6];
        G( "block_table_n: %x, block_table_block_table_n: %x", disc->partition[ partition_i ].oux.block_table_n, disc->partition[ partition_i ].oux.block_table_block_table_n );
        G( "directory_table_start: %x, directory_table_n: %x, directory_n: %x", disc->partition[ partition_i ].oux.block_table_directory_table_start, disc->partition[ partition_i ].oux.block_table_directory_table_n, disc->partition[ partition_i ].oux.directory_n );
        G( "file_table_start: %x, file_table_n: %x, file_n: %x", disc->partition[ partition_i ].oux.block_table_file_table_start, disc->partition[ partition_i ].oux.block_table_file_table_n, disc->partition[ partition_i ].oux.file_n );
        /*for_n( block_table_i, disc->partition[ partition_i ].oux.block_table_n )
        {   G( "block_table_i: %x, sector: %x", block_table_i, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector );
            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                G( "n: %x, pre: %16x, post: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post );
            else
                G( "start: %16x, size: %16x", disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size );
        }*/
        N continue_from = ~0;
        N data_i = 0;
        N64 block_table_i = ~0;
        do
        {   switch( continue_from )
            { case ~0:
                    block_table_i++;
                    if( block_table_i == disc->partition[ partition_i ].oux.block_table_n )
                        goto End_loop;
                    continue_from++;
              case 0:
                    E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                    , sector + disc->sata_ahci.physical_sector_size
                    );
              default:
                    if( continue_from == 1 )
                    {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                        , sector + disc->sata_ahci.physical_sector_size
                        );
                    }
                    if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                        switch( continue_from )
                        { case 2:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 3:
                                E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 4:
                                E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                                continue_from = ~0;
                        }
                    else
                        switch( continue_from )
                        { case 2:
                                E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 3:
                                E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                                continue_from = ~0;
                        }
            }
        }while( data != sector + disc->sata_ahci.physical_sector_size );
End_loop:;
        E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
        for_n( block_table_i_write, disc->partition[ partition_i ].oux.block_table_block_table_n )
        {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            {   if( disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.pre )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i, disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].sector - 1, 1, &sector, &r_ );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        return r;
                    Pc data = sector + ( disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.pre );
                    do
                    {   switch( continue_from )
                        { case ~0:
                                block_table_i++;
                                if( block_table_i == disc->partition[ partition_i ].oux.block_table_n ) // Sprawdzenie na czas testów.
                                {   G( "block table overflow" );
                                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    return ~0;
                                }
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          default:
                                if( continue_from == 1 )
                                {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                                    , sector + disc->sata_ahci.physical_sector_size
                                    );
                                }
                                if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                                    switch( continue_from )
                                    { case 2:
                                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                      case 3:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                      case 4:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                            continue_from = ~0;
                                    }
                                else
                                    switch( continue_from )
                                    { case 2:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                      case 3:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                            continue_from = ~0;
                                    }
                        }
                    }while( data != sector + disc->sata_ahci.physical_sector_size );
                    if( block_table_i >= disc->partition[ partition_i ].oux.block_table_changed_from )
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                }
                N r_;
                r = E_disc_I_write( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].sector
                , disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.n
                , &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    return r;
                for_n( sector_i, disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.n )
                {   Pc data = sector;
                    do
                    {   switch( continue_from )
                        { case ~0:
                                block_table_i++;
                                if( block_table_i == disc->partition[ partition_i ].oux.block_table_n ) // Sprawdzenie na czas testów.
                                {   G( "block table overflow" );
                                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    return ~0;
                                }
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          default:
                                if( continue_from == 1 )
                                {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                                    , sector + disc->sata_ahci.physical_sector_size
                                    );
                                }
                                if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                                    switch( continue_from )
                                    { case 2:
                                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                      case 3:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                      case 4:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                            continue_from = ~0;
                                    }
                                else
                                    switch( continue_from )
                                    { case 2:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                      case 3:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                            , sector + disc->sata_ahci.physical_sector_size
                                            );
                                            continue_from = ~0;
                                    }
                        }
                    }while( data != sector + disc->sata_ahci.physical_sector_size );
                    if( block_table_i >= disc->partition[ partition_i ].oux.block_table_changed_from )
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    sector += disc->sata_ahci.physical_sector_size;
                }
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                if( disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i
                    , disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].sector
                      + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.n
                    , 1, &sector, &r_
                    );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        return r;
                    Pc data = sector;
                    do
                    {   switch( continue_from )
                        { case ~0:
                                block_table_i++;
                                if( block_table_i == disc->partition[ partition_i ].oux.block_table_n ) // Sprawdzenie na czas testów.
                                {   G( "block table overflow" );
                                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                    return ~0;
                                }
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                                , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post
                                );
                          default:
                                if( continue_from == 1 )
                                {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                                    , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post
                                    );
                                }
                                if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                                    switch( continue_from )
                                    { case 2:
                                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                            , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post
                                            );
                                      case 3:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                            , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post
                                            );
                                      case 4:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                            , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post
                                            );
                                            continue_from = ~0;
                                    }
                                else
                                    switch( continue_from )
                                    { case 2:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                            , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post
                                            );
                                      case 3:
                                            E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                            , sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post
                                            );
                                            continue_from = ~0;
                                    }
                        }
                    }while( data != sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.sectors.post );
                    if( block_table_i >= disc->partition[ partition_i ].oux.block_table_changed_from )
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                }
            }else
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i, disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].sector, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    return r;
                Pc data = sector + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start;
                do
                {   switch( continue_from )
                    { case ~0:
                            block_table_i++;
                            if( block_table_i == disc->partition[ partition_i ].oux.block_table_n ) // Sprawdzenie na czas testów.
                            {   G( "block table overflow" );
                                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                                return ~0;
                            }
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].sector
                            , sector
                              + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.size
                            );
                      default:
                            if( continue_from == 1 )
                            {   E_ouxfs_Q_device_I_switch_item( N8, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type
                                , sector
                                  + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start
                                  + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.size
                                );
                            }
                            if( disc->partition[ partition_i ].oux.block_table[ block_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                                switch( continue_from )
                                { case 2:
                                        E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.n
                                        , sector
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.size
                                        );
                                  case 3:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.pre
                                        , sector
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.size
                                        );
                                  case 4:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.sectors.post
                                        , sector
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.size
                                        );
                                        continue_from = ~0;
                                }
                            else
                                switch( continue_from )
                                { case 2:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.start
                                        , sector
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.size
                                        );
                                  case 3:
                                        E_ouxfs_Q_device_I_switch_item( N16, disc->partition[ partition_i ].oux.block_table[ block_table_i ].location.in_sector.size
                                        , sector
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start
                                          + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.size
                                        );
                                        continue_from = ~0;
                                }
                    }
                }while( data != sector
                  + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.start
                  + disc->partition[ partition_i ].oux.block_table[ block_table_i_write ].location.in_sector.size
                );
                if( block_table_i >= disc->partition[ partition_i ].oux.block_table_changed_from )
                    ; //TODO Dodać oznaczanie ‘dirty’.
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
        }
        if( ~continue_from ) // Sprawdzenie na czas testów.
        {   G( "block table underflow" );
            return ~0;
        }
        disc->partition[ partition_i ].oux.block_table_changed_from = ~0;
    }
    if( ~disc->partition[ partition_i ].oux.directory_table_changed_from )
    {   N continue_from = ~0;
        N64 directory_i = ~0;
        N data_i = 0;
        N char_i;
        for_n( directory_table_i, disc->partition[ partition_i ].oux.block_table_directory_table_n )
            if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            {   if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.pre )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i
                    , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector - 1
                    , 1, &sector, &r_
                    );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        return r;
                    Pc data = sector + ( disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.pre );
                    do
                    {   switch( continue_from )
                        { case ~0:
                                directory_i++;
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 1:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].parent
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                                char_i = 0;
                          case 2:
                                if( data == sector + disc->sata_ahci.physical_sector_size )
                                    break;
                                do
                                {   *data = disc->partition[ partition_i ].oux.directory[ directory_i ].name[ char_i++ ];
                                }while( *data
                                && ++data != sector + disc->sata_ahci.physical_sector_size
                                );
                                if( data != sector + disc->sata_ahci.physical_sector_size )
                                {   data++;
                                    continue_from = ~0;
                                }
                        }
                    }while( data != sector + disc->sata_ahci.physical_sector_size );
                    if( directory_i >= disc->partition[ partition_i ].oux.directory_table_changed_from )
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                }
                N r_;
                r = E_disc_I_write( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.n
                , &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    return r;
                for_n( sector_i, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.n )
                {   Pc data = sector;
                    do
                    {   switch( continue_from )
                        { case ~0:
                                directory_i++;
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 1:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].parent
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                                char_i = 0;
                          case 2:
                                if( data == sector + disc->sata_ahci.physical_sector_size )
                                    break;
                                do
                                {   *data = disc->partition[ partition_i ].oux.directory[ directory_i ].name[ char_i++ ];
                                }while( *data
                                && ++data != sector + disc->sata_ahci.physical_sector_size
                                );
                                if( data != sector + disc->sata_ahci.physical_sector_size )
                                {   data++;
                                    continue_from = ~0;
                                }
                        }
                    }while( data != sector + disc->sata_ahci.physical_sector_size );
                    if( directory_i >= disc->partition[ partition_i ].oux.directory_table_changed_from )
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    sector += disc->sata_ahci.physical_sector_size;
                }
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i
                    , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector
                      + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.n
                    , 1, &sector, &r_
                    );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        return r;
                    Pc data = sector;
                    do
                    {   switch( continue_from )
                        { case ~0:
                                directory_i++;
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                                , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post
                                );
                          case 1:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].parent
                                , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post
                                );
                                char_i = 0;
                          case 2:
                                if( data == sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post )
                                    break;
                                do
                                {   *data = disc->partition[ partition_i ].oux.directory[ directory_i ].name[ char_i++ ];
                                }while( *data
                                && ++data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post
                                );
                                if( data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post )
                                {   data++;
                                    continue_from = ~0;
                                }
                        }
                    }while( data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.sectors.post );
                    if( directory_i >= disc->partition[ partition_i ].oux.directory_table_changed_from )
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                }
            }else
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].sector
                , 1, &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    return r;
                Pc data = sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start;
                do
                {   switch( continue_from )
                    { case ~0:
                            directory_i++;
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].uid
                            , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start
                              + directory_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                            );
                      case 1:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.directory[ directory_i ].parent
                            , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start
                              + directory_table_i ].location.in_sector.start + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                            );
                            char_i = 0;
                      case 2:
                            if( data == sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                            )
                                break;
                            do
                            {   *data = disc->partition[ partition_i ].oux.directory[ directory_i ].name[ char_i++ ];
                            }while( *data
                            && ++data != sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size );
                            if( data != sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size )
                            {   data++;
                                continue_from = ~0;
                            }
                    }
                }while( data != sector
                  + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.start
                  + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_directory_table_start + directory_table_i ].location.in_sector.size
                );
                if( directory_i >= disc->partition[ partition_i ].oux.directory_table_changed_from )
                    ; //TODO Dodać oznaczanie ‘dirty’.
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
        disc->partition[ partition_i ].oux.directory_table_changed_from = ~0;
    }
    if( ~disc->partition[ partition_i ].oux.file_table_changed_from )
    {   N continue_from = ~0;
        N64 file_i = ~0;
        N data_i = 0;
        N char_i;
        for_n( file_table_i, disc->partition[ partition_i ].oux.block_table_file_table_n )
        {   if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            {   if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.pre )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i
                    , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector - 1
                    , 1, &sector, &r_
                    );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        return r;
                    Pc data = sector + ( disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.pre );
                    do
                    {   switch( continue_from )
                        { case ~0:
                                file_i++;
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].uid
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 1:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].parent
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 2:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 3:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                                char_i = 0;
                          case 4:
                                if( data == sector + disc->sata_ahci.physical_sector_size )
                                    break;
                                do
                                {   *data = disc->partition[ partition_i ].oux.file[ file_i ].name[ char_i++ ];
                                }while( *data
                                && ++data != sector + disc->sata_ahci.physical_sector_size
                                );
                                if( data != sector + disc->sata_ahci.physical_sector_size )
                                {   data++;
                                    continue_from = ~0;
                                }
                        }
                    }while( data != sector + disc->sata_ahci.physical_sector_size );
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                }
                N r_;
                r = E_disc_I_write( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.n
                , &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    return r;
                for_n( sector_i, disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.n )
                {   Pc data = sector;
                    do
                    {   switch( continue_from )
                        { case ~0:
                                file_i++;
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].uid
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 1:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].parent
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 2:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                          case 3:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                                , sector + disc->sata_ahci.physical_sector_size
                                );
                                char_i = 0;
                          case 4:
                                if( data == sector + disc->sata_ahci.physical_sector_size )
                                    break;
                                do
                                {   *data = disc->partition[ partition_i ].oux.file[ file_i ].name[ char_i++ ];
                                }while( *data
                                && ++data != sector + disc->sata_ahci.physical_sector_size
                                );
                                if( data != sector + disc->sata_ahci.physical_sector_size )
                                {   data++;
                                    continue_from = ~0;
                                }
                        }
                    }while( data != sector + disc->sata_ahci.physical_sector_size );
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    sector += disc->sata_ahci.physical_sector_size;
                }
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                if( disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i
                    , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector
                      + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.n
                    , 1, &sector, &r_
                    );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        return r;
                    Pc data = sector;
                    do
                    {   switch( continue_from )
                        { case ~0:
                                file_i++;
                                continue_from++;
                          case 0:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].uid
                                , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                                );
                          case 1:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].parent
                                , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                                );
                          case 2:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                                , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                                );
                          case 3:
                                E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                                , sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                                );
                                char_i = 0;
                          case 4:
                                if( data == sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post )
                                    break;
                                do
                                {   *data = disc->partition[ partition_i ].oux.file[ file_i ].name[ char_i++ ];
                                }while( *data
                                && ++data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post
                                );
                                if( data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post )
                                {   data++;
                                    continue_from = ~0;
                                }
                        }
                    }while( data != sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.sectors.post );
                    if( file_i >= disc->partition[ partition_i ].oux.file_table_changed_from )
                        ; //TODO Dodać oznaczanie ‘dirty’.
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                }
            }else
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i
                , disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].sector
                , 1, &sector, &r_
                );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    return r;
                Pc data = sector + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start;
                do
                {   switch( continue_from )
                    { case ~0:
                            file_i++;
                            continue_from++;
                      case 0:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].uid
                            , sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                            );
                      case 1:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].parent
                            , sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                            );
                      case 2:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            , sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                            );
                      case 3:
                            E_ouxfs_Q_device_I_switch_item( N64, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            , sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                            );
                            char_i = 0;
                      case 4:
                            if( data == sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                            )
                                break;
                            do
                            {   *data = disc->partition[ partition_i ].oux.file[ file_i ].name[ char_i++ ];
                            }while( *data
                            && ++data != sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                            );
                            if( data != sector
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                              + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                            )
                            {   data++;
                                continue_from = ~0;
                            }
                    }
                }while( data != sector
                  + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.start
                  + disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.block_table_file_table_start + file_table_i ].location.in_sector.size
                );
                if( file_i >= disc->partition[ partition_i ].oux.file_table_changed_from )
                    ; //TODO Dodać oznaczanie ‘dirty’.
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
            }
        }
        disc->partition[ partition_i ].oux.file_table_changed_from = ~0;
    }
    return r;
}
_private
N
E_ouxfs_Q_device_W( I disc_id
, N partition_i
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    for_n( file_i, disc->partition[ partition_i ].oux.file_n )
        if( disc->partition[ partition_i ].oux.file[ file_i ].lock_write
        || disc->partition[ partition_i ].oux.file[ file_i ].lock_read
        )
        {   G( "file locked: file_i=%x", file_i );
            r = ~0;
            goto End;
        }
    r = E_ouxfs_Q_device_I_save( disc_id, partition_i );
    if(r)
        goto End;
    // Wyrzucenie z pamięci operacyjnej struktur systemu plików.
    for_n_( file_i, disc->partition[ partition_i ].oux.file_n )
        W( disc->partition[ partition_i ].oux.file[ file_i ].name );
    W( disc->partition[ partition_i ].oux.file );
    for_n( directory_i, disc->partition[ partition_i ].oux.directory_n )
        W( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
    W( disc->partition[ partition_i ].oux.directory );
    W( disc->partition[ partition_i ].oux.block_table );
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_private
N
E_ouxfs_Q_directory_I_list_directory( N disc_id
, N partition_i
, N64 uid
, N *n
, N64 **list
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    if( ~uid )
    {   N64 directory_i;
        r = E_ouxfs_Q_directory_R( disc_id, partition_i, uid, &directory_i );
        if(r)
            goto End;
    }
    Mt_( *list, 0 );
    if( !*list )
    {   r = ~0;
        goto End;
    }
    *n = 0;
    for_n( directory_i, disc->partition[ partition_i ].oux.directory_n )
        if( disc->partition[ partition_i ].oux.directory[ directory_i ].parent == uid )
        {   if( !E_mem_Q_blk_I_append( list, 1 ))
            {   r = W( *list );
                if( !r )
                    r = ~0;
                goto End;
            }
            (*list)[ *n ] = disc->partition[ partition_i ].oux.directory[ directory_i ].uid;
            (*n)++;
        }
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
_private
N
E_ouxfs_Q_directory_I_list_file( N disc_id
, N partition_i
, N64 uid
, N *n
, N64 **list
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    if( ~uid )
    {   N64 directory_i;
        r = E_ouxfs_Q_directory_R( disc_id, partition_i, uid, &directory_i );
        if(r)
            goto End;
    }
    Mt_( *list, 0 );
    if( !*list )
    {   r = ~0;
        goto End;
    }
    *n = 0;
    for_n( file_i, disc->partition[ partition_i ].oux.file_n )
        if( disc->partition[ partition_i ].oux.file[ file_i ].parent == uid )
        {   if( !E_mem_Q_blk_I_append( list, 1 ))
            {   r = W( *list );
                if( !r )
                    r = ~0;
                goto End;
            }
            (*list)[ *n ] = disc->partition[ partition_i ].oux.file[ file_i ].uid;
            (*n)++;
        }
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//------------------------------------------------------------------------------
_private
N
E_ouxfs_Q_directory_R_name( N disc_id
, N partition_i
, N64 uid
, Pc *name
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 directory_i;
    r = E_ouxfs_Q_directory_R( disc_id, partition_i, uid, &directory_i );
    if(r)
        goto End;
    *name = E_text_Z_s0_M_duplicate( disc->partition[ partition_i ].oux.directory[ directory_i ].name );
    if( !*name )
        r = ~0;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
_private
N
E_ouxfs_Q_directory_P_name( N disc_id
, N partition_i
, N64 uid
, const Pc name
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 directory_i;
    r = E_ouxfs_Q_directory_R( disc_id, partition_i, uid, &directory_i );
    if(r)
        goto End;
    N64 parent = disc->partition[ partition_i ].oux.directory[ directory_i ].parent;
    for_n_( directory_i, disc->partition[ partition_i ].oux.directory_n )
        if( disc->partition[ partition_i ].oux.directory[ directory_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.directory[ directory_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    for_n( file_i, disc->partition[ partition_i ].oux.file_n )
        if( disc->partition[ partition_i ].oux.file[ file_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.file[ file_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    r = E_ouxfs_Q_directory_file_I_block_append_truncate( disc_id, partition_i
    , E_text_Z_s0_R_l_0( disc->partition[ partition_i ].oux.directory[ directory_i ].name )
    , name
    , &disc->partition[ partition_i ].oux.block_table_directory_table_start
    , &disc->partition[ partition_i ].oux.block_table_directory_table_n
    , &disc->partition[ partition_i ].oux.directory_table_changed_from
    );
    if(r)
        goto End;
    if( !E_mem_Q_blk_M_replace( &disc->partition[ partition_i ].oux.directory[ directory_i ].name, E_text_Z_s0_R_l_0(name) ))
    {   r = ~0;
        goto End;
    }
    E_text_Z_s_P_copy_s0_0( disc->partition[ partition_i ].oux.directory[ directory_i ].name, name );
    if( disc->partition[ partition_i ].oux.directory_table_changed_from > directory_i )
        disc->partition[ partition_i ].oux.directory_table_changed_from = directory_i;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
_private
N
E_ouxfs_Q_file_R_name( N disc_id
, N partition_i
, N64 uid
, Pc *name
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    *name = E_text_Z_s0_M_duplicate( disc->partition[ partition_i ].oux.file[ file_i ].name );
    if( !*name )
        r = ~0;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
_private
N
E_ouxfs_Q_file_P_name( N disc_id
, N partition_i
, N64 uid
, const Pc name
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    N64 parent = disc->partition[ partition_i ].oux.file[ file_i ].parent;
    for_n( directory_i, disc->partition[ partition_i ].oux.directory_n )
        if( disc->partition[ partition_i ].oux.directory[ directory_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.directory[ directory_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    for_n_( file_i, disc->partition[ partition_i ].oux.file_n )
        if( disc->partition[ partition_i ].oux.file[ file_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.file[ file_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    r = E_ouxfs_Q_directory_file_I_block_append_truncate( disc_id, partition_i
    , E_text_Z_s0_R_l_0( disc->partition[ partition_i ].oux.file[ file_i ].name )
    , name
    , &disc->partition[ partition_i ].oux.block_table_file_table_start
    , &disc->partition[ partition_i ].oux.block_table_file_table_n
    , &disc->partition[ partition_i ].oux.file_table_changed_from
    );
    if(r)
        goto End;
    if( !E_mem_Q_blk_M_replace( &disc->partition[ partition_i ].oux.file[ file_i ].name, E_text_Z_s0_R_l_0(name) ))
    {   r = ~0;
        goto End;
    }
    E_text_Z_s_P_copy_s0_0( disc->partition[ partition_i ].oux.file[ file_i ].name, name );
    if( disc->partition[ partition_i ].oux.file_table_changed_from > file_i )
        disc->partition[ partition_i ].oux.file_table_changed_from = file_i;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//------------------------------------------------------------------------------
_private
N
E_ouxfs_Q_file_R_size( N disc_id
, N partition_i
, N64 uid
, N64 *n
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    *n = E_ouxfs_Z_start_n_R_size( disc_id, partition_i, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n );
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//------------------------------------------------------------------------------
_private
N
E_ouxfs_Q_directory_I_move( N disc_id
, N partition_i
, N64 uid
, N64 parent
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 directory_i;
    r = E_ouxfs_Q_directory_R( disc_id, partition_i, uid, &directory_i );
    if(r)
        goto End;
    if( ~parent )
    {   N64 directory_i;
        r = E_ouxfs_Q_directory_R( disc_id, partition_i, parent, &directory_i );
        if(r)
            goto End;
    }
    const Pc name = disc->partition[ partition_i ].oux.directory[ directory_i ].name;
    for_n_( directory_i, disc->partition[ partition_i ].oux.directory_n )
        if( disc->partition[ partition_i ].oux.directory[ directory_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.directory[ directory_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    for_n( file_i, disc->partition[ partition_i ].oux.file_n )
        if( disc->partition[ partition_i ].oux.file[ file_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.file[ file_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    if( disc->partition[ partition_i ].oux.directory[ directory_i ].parent == parent )
    {   r = ~0;
        goto End;
    }
    disc->partition[ partition_i ].oux.directory[ directory_i ].parent = parent;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
_private
N
E_ouxfs_Q_file_I_move( N disc_id
, N partition_i
, N64 uid
, N64 parent
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    if( ~parent )
    {   N64 directory_i;
        r = E_ouxfs_Q_directory_R( disc_id, partition_i, parent, &directory_i );
        if(r)
            goto End;
    }
    const Pc name = disc->partition[ partition_i ].oux.file[ file_i ].name;
    for_n( directory_i, disc->partition[ partition_i ].oux.directory_n )
        if( disc->partition[ partition_i ].oux.directory[ directory_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.directory[ directory_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    for_n_( file_i, disc->partition[ partition_i ].oux.file_n )
        if( disc->partition[ partition_i ].oux.file[ file_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.file[ file_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    if( disc->partition[ partition_i ].oux.file[ file_i ].parent == parent )
    {   r = ~0;
        goto End;
    }
    disc->partition[ partition_i ].oux.file[ file_i ].parent = parent;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//------------------------------------------------------------------------------
_private
N
E_ouxfs_Q_file_I_truncate( N disc_id
, N partition_i
, N64 uid
, N64 size
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    if( disc->partition[ partition_i ].oux.file[ file_i ].lock_write
    || disc->partition[ partition_i ].oux.file[ file_i ].lock_read
    )
    {   r = ~0;
        goto End;
    }
    N64 size_orig = E_ouxfs_Z_start_n_R_size( disc_id, partition_i, disc->partition[ partition_i ].oux.file[ file_i ].block_table.start, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n );
    if( size > size_orig )
    {   r = ~0;
        goto End;
    }
    if( size_orig - size )
    {   S64 block_table_diff__;
        r = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i, size_orig - size
        , disc->partition[ partition_i ].oux.file[ file_i ].block_table.start, &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
        , &block_table_diff__
        );
        while( block_table_diff__ )
        {   S64 block_table_diff_above = disc->partition[ partition_i ].oux.block_table_size + block_table_diff__ > disc->partition[ partition_i ].oux.first_sector_max_size
            ? -block_table_diff__
            : disc->partition[ partition_i ].oux.block_table_size - disc->partition[ partition_i ].oux.first_sector_max_size;
            disc->partition[ partition_i ].oux.block_table_size += block_table_diff__;
            if( block_table_diff_above <= 0 )
                break;
            N r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i, block_table_diff_above
            , 0, &disc->partition[ partition_i ].oux.block_table_block_table_n
            , &block_table_diff__
            );
            if( r_ )
                r = r_;
        }
    }
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_private
N
E_ouxfs_Q_directory_M( N disc_id
, N partition_i
, N64 parent
, const Pc name
, N64 *uid
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    if( !~disc->partition[ partition_i ].oux.directory_n )
    {   r = ~0;
        goto End;
    }
    if( ~parent )
    {   N64 parent_directory_i;
        r = E_ouxfs_Q_directory_R( disc_id, partition_i, parent, &parent_directory_i );
        if(r)
            goto End;
    }
    for_n( directory_i, disc->partition[ partition_i ].oux.directory_n )
        if( disc->partition[ partition_i ].oux.directory[ directory_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.directory[ directory_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    for_n( file_i, disc->partition[ partition_i ].oux.file_n )
        if( disc->partition[ partition_i ].oux.file[ file_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.file[ file_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    r = E_ouxfs_Q_directory_file_I_block_append( disc_id, partition_i, 2 * sizeof( N64 ) + E_text_Z_s0_R_l_0(name)
    , &disc->partition[ partition_i ].oux.block_table_directory_table_start
    , &disc->partition[ partition_i ].oux.block_table_directory_table_n
    , &disc->partition[ partition_i ].oux.directory_table_changed_from
    );
    if(r)
        goto End;
    if( disc->partition[ partition_i ].oux.directory_n )
    {   *uid = disc->partition[ partition_i ].oux.directory[ disc->partition[ partition_i ].oux.directory_n - 1 ].uid + 1;
        if( ~*uid )
            directory_i = disc->partition[ partition_i ].oux.directory_n;
        else
        {   *uid = 0;
            for_n_( directory_i, disc->partition[ partition_i ].oux.directory_n )
            {
                if( *uid != disc->partition[ partition_i ].oux.directory[ directory_i ].uid )
                    break;
                (*uid)++;
            }
        }
    }else
    {   *uid = 0;
        directory_i = disc->partition[ partition_i ].oux.directory_n;
    }
    Pc name_ = E_text_Z_s0_M_duplicate(name);
    if( !name_ )
    {   r = ~0;
        goto End;
    }
    if( !E_mem_Q_blk_I_insert( &disc->partition[ partition_i ].oux.directory, directory_i, 1 ))
    {   r = ~0;
        W( name_ );
        goto End;
    }
    disc->partition[ partition_i ].oux.directory_n++;
    disc->partition[ partition_i ].oux.directory[ directory_i ].uid = *uid;
    disc->partition[ partition_i ].oux.directory[ directory_i ].parent = parent;
    disc->partition[ partition_i ].oux.directory[ directory_i ].name = name_;
    if( disc->partition[ partition_i ].oux.directory_table_changed_from > directory_i )
        disc->partition[ partition_i ].oux.directory_table_changed_from = directory_i;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
_private
N
E_ouxfs_Q_directory_W( N disc_id
, N partition_i
, N64 uid
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 directory_i;
    r = E_ouxfs_Q_directory_R( disc_id, partition_i, uid, &directory_i );
    if(r)
        goto End;
    if( W( disc->partition[ partition_i ].oux.directory[ directory_i ].name ))
    {   r = ~0;
        goto End;   
    }
    if( !E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.directory, directory_i, 1 ))
    {   r = ~0;
        goto End;
    }
    disc->partition[ partition_i ].oux.directory_n--;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//------------------------------------------------------------------------------
_private
N
E_ouxfs_Q_file_M( N disc_id
, N partition_i
, N64 parent
, const Pc name
, N64 *uid
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    if( !~disc->partition[ partition_i ].oux.file_n )
    {   r = ~0;
        goto End;
    }
    if( ~parent )
    {   N64 parent_directory_i;
        r = E_ouxfs_Q_directory_R( disc_id, partition_i, parent, &parent_directory_i );
        if(r)
            goto End;
    }
    for_n( directory_i, disc->partition[ partition_i ].oux.directory_n )
        if( disc->partition[ partition_i ].oux.directory[ directory_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.directory[ directory_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    for_n( file_i, disc->partition[ partition_i ].oux.file_n )
        if( disc->partition[ partition_i ].oux.file[ file_i ].parent == parent
        && E_text_Z_s0_T_eq_s0( disc->partition[ partition_i ].oux.file[ file_i ].name, name )
        )
        {   r = ~0;
            goto End;
        }
    r = E_ouxfs_Q_directory_file_I_block_append( disc_id, partition_i, 4 * sizeof( N64 ) + E_text_Z_s0_R_l_0(name)
    , &disc->partition[ partition_i ].oux.block_table_file_table_start
    , &disc->partition[ partition_i ].oux.block_table_file_table_n
    , &disc->partition[ partition_i ].oux.file_table_changed_from
    );
    if(r)
        goto End;
    if( disc->partition[ partition_i ].oux.file_n )
    {   *uid = disc->partition[ partition_i ].oux.file[ disc->partition[ partition_i ].oux.file_n - 1 ].uid + 1;
        if( ~*uid )
            file_i = disc->partition[ partition_i ].oux.file_n;
        else
        {   *uid = 0;
            for_n_( file_i, disc->partition[ partition_i ].oux.file_n )
            {   if( *uid != disc->partition[ partition_i ].oux.file[ file_i ].uid )
                    break;
                ( *uid )++;
            }
        }
    }else
    {   *uid = 0;
        file_i = disc->partition[ partition_i ].oux.file_n;
    }
    Pc name_ = E_text_Z_s0_M_duplicate(name);
    if( !name_ )
    {   r = ~0;
        goto End;
    }
    if( !E_mem_Q_blk_I_insert( &disc->partition[ partition_i ].oux.file, file_i, 1 ))
    {   r = ~0;
        if( W( name_ ))
            r = ~1;
        goto End;
    }
    disc->partition[ partition_i ].oux.file_n++;
    disc->partition[ partition_i ].oux.file[ file_i ].uid = *uid;
    disc->partition[ partition_i ].oux.file[ file_i ].parent = parent;
    disc->partition[ partition_i ].oux.file[ file_i ].block_table.n = 0;
    disc->partition[ partition_i ].oux.file[ file_i ].name = name_;
    disc->partition[ partition_i ].oux.file[ file_i ].lock_write = no;
    disc->partition[ partition_i ].oux.file[ file_i ].lock_read = no;
    if( disc->partition[ partition_i ].oux.file_table_changed_from > file_i )
        disc->partition[ partition_i ].oux.file_table_changed_from = file_i;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
_private
N
E_ouxfs_Q_file_W( N disc_id
, N partition_i
, N64 uid
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    if( disc->partition[ partition_i ].oux.file[ file_i ].lock_write
    || disc->partition[ partition_i ].oux.file[ file_i ].lock_read
    )
    {   r = ~0;
        goto End;
    }
    if( disc->partition[ partition_i ].oux.file[ file_i ].block_table.n )
    {   if( disc->partition[ partition_i ].oux.block_table_changed_from > disc->partition[ partition_i ].oux.file[ file_i ].block_table.start )
            disc->partition[ partition_i ].oux.block_table_changed_from = disc->partition[ partition_i ].oux.file[ file_i ].block_table.start;
        for_n( block_table_i, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n )
        {   r = E_ouxfs_Q_free_table_I_unite( disc_id, partition_i, &disc->partition[ partition_i ].oux.block_table[ disc->partition[ partition_i ].oux.file[ file_i ].block_table.start + block_table_i ] );
            if(r)
                goto End;
        }
        if( disc->partition[ partition_i ].oux.block_table_directory_table_start > disc->partition[ partition_i ].oux.file[ file_i ].block_table.start )
            disc->partition[ partition_i ].oux.block_table_directory_table_start -= disc->partition[ partition_i ].oux.file[ file_i ].block_table.n;
        if( disc->partition[ partition_i ].oux.block_table_file_table_start > disc->partition[ partition_i ].oux.file[ file_i ].block_table.start )
            disc->partition[ partition_i ].oux.block_table_file_table_start -= disc->partition[ partition_i ].oux.file[ file_i ].block_table.n;
        for_n( file_i_, disc->partition[ partition_i ].oux.file_n )
            if( file_i_ != file_i
            && disc->partition[ partition_i ].oux.file[ file_i_ ].block_table.start > disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
            )
                disc->partition[ partition_i ].oux.file[ file_i_ ].block_table.start -= disc->partition[ partition_i ].oux.file[ file_i ].block_table.n;
        if( E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.block_table
        , disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
        , disc->partition[ partition_i ].oux.block_table_n - ( disc->partition[ partition_i ].oux.file[ file_i ].block_table.start + disc->partition[ partition_i ].oux.file[ file_i ].block_table.n )
        ))
        {   r = ~0;
            goto End;
        }
        disc->partition[ partition_i ].oux.block_table_n -= disc->partition[ partition_i ].oux.file[ file_i ].block_table.n;
    }
    if( W( disc->partition[ partition_i ].oux.file[ file_i ].name ))
    {   r = ~0;
        goto End;   
    }
    if( E_mem_Q_blk_I_remove( &disc->partition[ partition_i ].oux.file, file_i, 1 ))
    {   r = ~0;
        goto End;
    }
    disc->partition[ partition_i ].oux.file_n--;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_private
N
E_ouxfs_Q_file_I_lock( N disc_id
, N partition_i
, N64 uid
, enum E_ouxfs_Z_file_Z_lock operation
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    switch(operation)
    { case E_ouxfs_Z_file_Z_lock_S_unlock:
            if( !disc->partition[ partition_i ].oux.file[ file_i ].lock_write
            && !disc->partition[ partition_i ].oux.file[ file_i ].lock_read
            )
            {   r = ~0;
                goto End;
            }
            disc->partition[ partition_i ].oux.file[ file_i ].lock_write = no;
            disc->partition[ partition_i ].oux.file[ file_i ].lock_read = no;
            break;
      case E_ouxfs_Z_file_Z_lock_S_exclusive:
            if( disc->partition[ partition_i ].oux.file[ file_i ].lock_write
            || disc->partition[ partition_i ].oux.file[ file_i ].lock_read
            )
            {   r = ~0;
                goto End;
            }
            disc->partition[ partition_i ].oux.file[ file_i ].lock_write = yes;
            disc->partition[ partition_i ].oux.file[ file_i ].lock_read = yes;
            break;
      default: // E_ouxfs_Z_file_Z_lock_S_shared:
            if( disc->partition[ partition_i ].oux.file[ file_i ].lock_write
            || !disc->partition[ partition_i ].oux.file[ file_i ].lock_read
            )
            {   r = ~0;
                goto End;
            }
            disc->partition[ partition_i ].oux.file[ file_i ].lock_write = yes;
            disc->partition[ partition_i ].oux.file[ file_i ].lock_read = no;
            break;
    }
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
//------------------------------------------------------------------------------
_private
N
E_ouxfs_Q_file_I_read( N disc_id
, N partition_i
, N64 uid
, N64 pos
, N64 *n
, Pc data
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    if( disc->partition[ partition_i ].oux.file[ file_i ].lock_read )
    {   r = ~0;
        goto End;
    }
    Pc sector;
    N64 data_p = 0;
    for_n( block_table_i, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n )
    {   struct E_ouxfs_Z_block *block = disc->partition[ partition_i ].oux.block_table + disc->partition[ partition_i ].oux.file[ file_i ].block_table.start + block_table_i;
        if( block->location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if( pos < block->location.sectors.pre )
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i, block->sector - 1, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End;
                N64 n_ = J_min( *n, block->location.sectors.pre );
                if( n_ > pos )
                    n_ -= pos;
                E_mem_Q_blk_I_copy( data + data_p, sector + ( disc->sata_ahci.physical_sector_size - block->location.sectors.pre ) + pos, n_ );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                data_p += n_;
                *n -= n_;
                if( !*n )
                    break;
                pos = 0;
            }else
                pos -= block->location.sectors.pre;
            for_n( sector_i, block->location.sectors.n )
            {   if( pos < disc->sata_ahci.physical_sector_size )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i, block->sector + sector_i, 1, &sector, &r_ );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        goto End;
                    N64 n_ = J_min( *n, disc->sata_ahci.physical_sector_size );
                    if( n_ > pos )
                        n_ -= pos;
                    E_mem_Q_blk_I_copy( data + data_p, sector + pos, n_ );
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                    data_p += n_;
                    *n -= n_;
                    if( !*n )
                        goto Loop_end;
                    pos = 0;
                }else
                    pos -= disc->sata_ahci.physical_sector_size;
            }
            if( pos < block->location.sectors.post )
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i, block->sector + block->location.sectors.n, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End;
                N64 n_ = J_min( *n, block->location.sectors.post );
                if( n_ > pos )
                    n_ -= pos;
                E_mem_Q_blk_I_copy( data + data_p, sector + pos, n_ );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                data_p += n_;
                *n -= n_;
                if( !*n )
                    break;
                pos = 0;
            }else
                pos -= block->location.sectors.post;
        }else
            if( pos < block->location.in_sector.size )
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i, block->sector, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End;
                N64 n_ = J_min( *n, block->location.in_sector.size );
                if( n_ > pos )
                    n_ -= pos;
                E_mem_Q_blk_I_copy( data + data_p, sector + block->location.in_sector.start + pos, n_ );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                data_p += n_;
                *n -= n_;
                if( !*n )
                    break;
                pos = 0;
            }else
                pos -= block->location.in_sector.size;
    }
Loop_end:
    if(pos)
        r = ~0;
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
_private
N
E_ouxfs_Q_file_I_write( I disc_id
, N partition_i
, N64 uid
, N64 pos
, N64 n
, const Pc data
){  N r = 0;
    struct E_disc_Z *disc = E_mem_Q_tab_R( E_disc_S, disc_id );
    if( E_flow_I_lock_r( &disc->partition[ partition_i ].lock, &r ))
        return ~0;
    N64 file_i;
    r = E_ouxfs_Q_file_R( disc_id, partition_i, uid, &file_i );
    if(r)
        goto End;
    if( disc->partition[ partition_i ].oux.file[ file_i ].lock_write )
    {   r = ~0;
        goto End;
    }
    Pc sector;
    N64 data_p = 0;
    for_n( block_table_i, disc->partition[ partition_i ].oux.file[ file_i ].block_table.n )
    {   struct E_ouxfs_Z_block *block = disc->partition[ partition_i ].oux.block_table + disc->partition[ partition_i ].oux.file[ file_i ].block_table.start + block_table_i;
        if( block->location_type == E_ouxfs_Z_block_Z_location_S_sectors )
        {   if( pos < block->location.sectors.pre )
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i, block->sector - 1, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End;
                N64 n_ = J_min( n, block->location.sectors.pre - pos );
                E_mem_Q_blk_I_copy( sector + ( disc->sata_ahci.physical_sector_size - block->location.sectors.pre ) + pos, data + data_p, n_ );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                data_p += n_;
                n -= n_;
                if( !n )
                    break;
                pos = 0;
            }else
                pos -= block->location.sectors.pre;
            for_n( sector_i, block->location.sectors.n )
            {   if( pos < disc->sata_ahci.physical_sector_size )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i, block->sector + sector_i, 1, &sector, &r_ );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        goto End;
                    N64 n_ = J_min( n, disc->sata_ahci.physical_sector_size - pos );
                    E_mem_Q_blk_I_copy( sector + pos, data + data_p, n_ );
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                    data_p += n_;
                    n -= n_;
                    if( !n )
                        break;
                    pos = 0;
                }else
                    pos -= disc->sata_ahci.physical_sector_size;
            }
            if( pos < block->location.sectors.post )
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i, block->sector + block->location.sectors.n, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End;
                N64 n_ = J_min( n, block->location.sectors.post - pos );
                E_mem_Q_blk_I_copy( sector + pos, data + data_p, n_ );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                data_p += n_;
                n -= n_;
                if( !n )
                    break;
                pos = 0;
            }else
                pos -= block->location.sectors.post;
        }else
            if( pos < block->location.in_sector.size )
            {   N r_;
                r = E_disc_I_read( disc_id, partition_i, block->sector, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End;
                N64 n_ = J_min( n, block->location.in_sector.size - pos );
                E_mem_Q_blk_I_copy( sector + block->location.in_sector.start + pos, data + data_p, n_ );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                data_p += n_;
                n -= n_;
                if( !n )
                    break;
                pos = 0;
            }else
                pos -= block->location.in_sector.size;
    }
    if(pos)
    {   G( "write past end of file: %x", pos );
        r = ~0;
        goto End;
    }
    if(n)
    {   if( !disc->partition[ partition_i ].oux.free_table_n )
        {   G( "no space left on device: %x", n );
            r = ~0;
            goto End;
        }
        N64 n_0 = n;
        S64 block_table_diff = 0;
        N64 size;
        N64 free_table_found_i;
        N64 block_n = disc->partition[ partition_i ].oux.file[ file_i ].block_table.n;
        if( block_n )
        {   // Szukaj wolnego bloku przyległego od góry do ostatniego przydzielonego.
            N64 block_start = disc->partition[ partition_i ].oux.file[ file_i ].block_table.start;
            N64 free_table_i = E_ouxfs_Q_free_table_R( disc_id, partition_i, disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector + 1 );
            if( free_table_i == disc->partition[ partition_i ].oux.free_table_n )
                free_table_i--;
            if( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                for( ; ~free_table_i; free_table_i-- )
                {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                      ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                        + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                        + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
                      : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                      < disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector
                      + disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.n
                    )
                        break;
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                    {   if(( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector
                            + disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.n
                            == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                          && disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.post
                            + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                            == disc->sata_ahci.physical_sector_size
                        )
                        || ( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector
                            + disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.n
                            == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                          && !disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.post
                          && !disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                        ))
                        {   free_table_found_i = free_table_i;
                            goto Write;
                        }
                    }else
                    {   if(( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector
                            + disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.n
                            == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                          && disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.post == disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                        )
                        || ( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector
                            + disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.n
                            == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                          && !disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.sectors.post
                          && !disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                        ))
                        {   free_table_found_i = free_table_i;
                            goto Write;
                        }
                    }
                }
            else
            {   while( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector == disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector + 1
                && free_table_i != disc->partition[ partition_i ].oux.free_table_n - 1
                )
                    free_table_i++;
                for( ; ~free_table_i; free_table_i-- )
                {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                      ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                        + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                        + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
                      : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector < disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector )
                        break;
                    if( disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
                    {   if( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                        && ( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.in_sector.start
                          + disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.in_sector.size
                          == disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                        ))
                        {   free_table_found_i = free_table_i;
                            goto Write;
                        }
                    }else
                    {   if(( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector
                          && disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.in_sector.start
                            + disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.in_sector.size
                            == disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                        )
                        || ( disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].sector == disc->partition[ partition_i ].oux.free_table[ free_table_i ].sector - 1
                          && disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.in_sector.start
                            + disc->partition[ partition_i ].oux.block_table[ block_start + block_n - 1 ].location.in_sector.size
                            == disc->sata_ahci.physical_sector_size
                          && !disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.start
                        ))
                        {   free_table_found_i = free_table_i;
                            goto Write;
                        }
                    }
                }
            }
        }
        // Szukaj wolnego bloku na całe żądane dopisywane dane.
        N64 lowest_size = ~0;
        for_n( free_table_i, disc->partition[ partition_i ].oux.free_table_n )
        {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
              ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
              : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
            if( size >= n
            && lowest_size > size
            )
            {   lowest_size = size;
                free_table_found_i = free_table_i;
                if( size == n )
                    break;
            }
        }
        if( ~lowest_size )
        {   size = lowest_size;
            goto Write;
        }
        O{  if( !disc->partition[ partition_i ].oux.free_table_n )
            {   G( "no space left on device: %x", n );
                r = ~0;
                goto End;
            }
            // Szukaj największego wolnego bloku mniejszego od żądanych dopisywanych danych.
            N64 greatest_size = 0;
            for_n( free_table_i, disc->partition[ partition_i ].oux.free_table_n )
            {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                  ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                    + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                    + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
                  : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                if( greatest_size < size )
                {   if( size >= n )
                        break;
                    greatest_size = size;
                    free_table_found_i = free_table_i;
                }
            }
            if( free_table_i == disc->partition[ partition_i ].oux.free_table_n )
                size = greatest_size;
            else
            {   // Szukaj wolnego bloku na całe żądane dopisywane dane.
                N64 lowest_size = ~0;
                for_n( free_table_i, disc->partition[ partition_i ].oux.free_table_n )
                {   size = disc->partition[ partition_i ].oux.free_table[ free_table_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors
                      ? disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.pre
                        + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.n * disc->sata_ahci.physical_sector_size
                        + disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.sectors.post
                      : disc->partition[ partition_i ].oux.free_table[ free_table_i ].location.in_sector.size;
                    if( size >= n
                    && lowest_size > size
                    )
                    {   lowest_size = size;
                        free_table_found_i = free_table_i;
                        if( size == n )
                            break;
                    }
                }
                size = lowest_size;
            }
Write:      N64 n_;
            if( disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type == E_ouxfs_Z_block_Z_location_S_sectors )
            {   if( disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre )
                {   n_ = J_min( n, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre );
                    N r_;
                    r = E_disc_I_read( disc_id, partition_i, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector - 1, 1, &sector, &r_ );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        goto End;
                    E_mem_Q_blk_I_copy( sector + ( disc->sata_ahci.physical_sector_size - disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre ), data + data_p, n_ );
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                    data_p += n_;
                    n -= n_;
                    if( !n )
                    {   N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
                        , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                        , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                        , free_table_found_i, size - n_
                        , &block_table_diff
                        );
                        if( !~r_
                        || r_ == ~1
                        )
                        {   disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre -= n_;
                            if( !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre
                            && !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n
                            )
                            {   N16 post = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start = 0;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size = post;
                            }
                        }
                        if( r_ )
                            r = r_;
                        if( !~r_ )
                        {   r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                            , n_0 - ( n + n_ )
                            , disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            , &block_table_diff
                            );
                            if( r_ )
                                r = r_;
                        }
                        break;
                    }
                }
                N sector_i = J_min( n / disc->sata_ahci.physical_sector_size, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n );
                N r_;
                r = E_disc_I_write( disc_id, partition_i, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector, sector_i, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End;
                E_mem_Q_blk_I_copy( sector, data + data_p, sector_i * disc->sata_ahci.physical_sector_size );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                data_p += sector_i * disc->sata_ahci.physical_sector_size;
                n -= sector_i * disc->sata_ahci.physical_sector_size;
                N n_;
                if( sector_i != disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n )
                {   N r_;
                    r = E_disc_I_read( disc_id, partition_i, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector + sector_i, 1, &sector, &r_ );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        goto End;
                    E_mem_Q_blk_I_copy( sector, data + data_p, n );
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                    data_p += n;
                    n_ = n;
                    n = 0;
                }else
                    n_ = disc->sata_ahci.physical_sector_size;
                if( !n )
                {   sector_i--;
                    N64 size_left = size
                        - ( disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre
                        + sector_i * disc->sata_ahci.physical_sector_size
                        + n_
                        );
                    N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
                    , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                    , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                    , free_table_found_i, size_left
                    , &block_table_diff
                    );
                    if(( !r_
                      || r_ == ~1
                    )
                    && size_left
                    )
                    {   N16 post = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector += sector_i + 1;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n -= sector_i + 1;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre = disc->sata_ahci.physical_sector_size - n_;
                        if( !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n )
                            if( !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post )
                            {   N16 pre = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector--;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start = disc->sata_ahci.physical_sector_size - pre;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size = pre;
                            }else if( !disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.pre )
                            {   disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start = 0;
                                disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size = post;
                            }
                    }
                    if( !r_
                    || r_ == ~1
                    )
                        r = r_;
                    if( !~r_ )
                    {   r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                        , n_0 - ( n + n_ )
                        , disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                        , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                        , &block_table_diff
                        );
                        if( r_ )
                            r = r_;
                    }
                    goto Loop_end;
                }
                if( disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post )
                {   n_ = J_min( n, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post );
                    N16 post = disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.post;
                    N r_;
                    r = E_disc_I_read( disc_id, partition_i, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector + disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n, 1, &sector, &r_ );
                    disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                    if(r)
                        goto End;
                    E_mem_Q_blk_I_copy( sector, data + data_p, n_ );
                    E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                    data_p += n_;
                    n -= n_;
                    if( !n )
                    {   N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
                        , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                        , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                        , free_table_found_i, post - n_
                        , &block_table_diff
                        );
                        if(( !r_
                          || r_ == ~1
                        )
                        && post != n_
                        )
                        {   disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector += disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.sectors.n;
                            disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location_type = E_ouxfs_Z_block_Z_location_S_in_sector;
                            disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start = n_;
                            disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size = post - disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start;
                        }
                        if( r_ )
                            r = r_;
                        if( !~r_ )
                        {   r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                            , n_0 - ( n + n_ )
                            , disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                            , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                            , &block_table_diff
                            );
                            if( r_ )
                                r = r_;
                        }
                        break;
                    }
                }
            }else
            {   n_ = J_min( n, size );
                N r_;
                r = E_disc_I_read( disc_id, partition_i, disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].sector, 1, &sector, &r_ );
                disc = E_mem_Q_tab_R( E_disc_S, disc_id );
                if(r)
                    goto End;
                E_mem_Q_blk_I_copy( sector + disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start, data + data_p, n_ );
                E_flow_I_unlock_r( &disc->sata_ahci.ssd_cache_lock, &r_, 0 );
                data_p += n_;
                n -= n_;
                if( !n )
                {   N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
                    , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                    , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                    , free_table_found_i, size - n_
                    , &block_table_diff
                    );
                    if(( !r_
                      || r_ == ~1
                    )
                    && size != n_
                    )
                    {   disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.start += n_;
                        disc->partition[ partition_i ].oux.free_table[ free_table_found_i ].location.in_sector.size -= n_;
                    }
                    if( r_ )
                        r = r_;
                    if( !~r_ )
                    {   r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                        , n_0 - ( n + n_ )
                        , disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                        , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                        , &block_table_diff
                        );
                        if( r_ )
                            r = r_;
                    }
                    break;
                }
            }
            N r_ = E_ouxfs_Q_block_table_I_unite( disc_id, partition_i
            , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
            , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
            , free_table_found_i, 0, &block_table_diff
            );
            if( r_ )
                r = r_;
            if( !~r_ )
            {   r_ = E_ouxfs_Z_start_n_I_block_truncate( disc_id, partition_i
                , n_0 - ( n + n_ )
                , disc->partition[ partition_i ].oux.file[ file_i ].block_table.start
                , &disc->partition[ partition_i ].oux.file[ file_i ].block_table.n
                , &block_table_diff
                );
                if( r_ )
                    r = r_;
                break;
            }
        }
Loop_end:   
        N r_ = E_ouxfs_Q_block_table_I_append_truncate( disc_id, partition_i, block_table_diff );
        if( r_ )
            r = r_;
    }
End:E_flow_I_unlock_r( &disc->partition[ partition_i ].lock, &r, r );
    return r;
}
/******************************************************************************/
